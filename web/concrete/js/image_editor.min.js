var Kinetic = {};

(function() {
    Kinetic.version = "4.4.3";
    Kinetic.Filters = {};
    Kinetic.DD = {};
    Kinetic.Global = {
        stages: [],
        idCounter: 0,
        ids: {},
        names: {},
        shapes: {},
        isDragging: function() {
            var dd = Kinetic.DD;
            if (!dd) {
                return false;
            } else {
                return dd.isDragging;
            }
        },
        isDragReady: function() {
            var dd = Kinetic.DD;
            if (!dd) {
                return false;
            } else {
                return !!dd.node;
            }
        },
        warn: function(str) {
            if (window.console && console.warn) {
                console.warn("Kinetic warning: " + str);
            }
        },
        extend: function(c1, c2) {
            for (var key in c2.prototype) {
                if (!(key in c1.prototype)) {
                    c1.prototype[key] = c2.prototype[key];
                }
            }
        },
        _addId: function(node, id) {
            if (id !== undefined) {
                this.ids[id] = node;
            }
        },
        _removeId: function(id) {
            if (id !== undefined) {
                delete this.ids[id];
            }
        },
        _addName: function(node, name) {
            if (name !== undefined) {
                if (this.names[name] === undefined) {
                    this.names[name] = [];
                }
                this.names[name].push(node);
            }
        },
        _removeName: function(name, _id) {
            if (name !== undefined) {
                var nodes = this.names[name];
                if (nodes !== undefined) {
                    for (var n = 0; n < nodes.length; n++) {
                        var no = nodes[n];
                        if (no._id === _id) {
                            nodes.splice(n, 1);
                        }
                    }
                    if (nodes.length === 0) {
                        delete this.names[name];
                    }
                }
            }
        }
    };
})();

(function(root, factory) {
    if (typeof exports === "object") {
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
        define(factory);
    } else {
        root.returnExports = factory();
    }
})(this, function() {
    return Kinetic;
});

(function() {
    var CANVAS = "canvas", CONTEXT_2D = "2d", OBJECT_ARRAY = "[object Array]", OBJECT_NUMBER = "[object Number]", OBJECT_STRING = "[object String]", PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI;
    Kinetic.Type = {
        _isElement: function(obj) {
            return !!(obj && obj.nodeType == 1);
        },
        _isFunction: function(obj) {
            return !!(obj && obj.constructor && obj.call && obj.apply);
        },
        _isObject: function(obj) {
            return !!obj && obj.constructor == Object;
        },
        _isArray: function(obj) {
            return Object.prototype.toString.call(obj) == OBJECT_ARRAY;
        },
        _isNumber: function(obj) {
            return Object.prototype.toString.call(obj) == OBJECT_NUMBER;
        },
        _isString: function(obj) {
            return Object.prototype.toString.call(obj) == OBJECT_STRING;
        },
        _hasMethods: function(obj) {
            var names = [], key;
            for (key in obj) {
                if (this._isFunction(obj[key])) {
                    names.push(key);
                }
            }
            return names.length > 0;
        },
        _isInDocument: function(el) {
            while (el = el.parentNode) {
                if (el == document) {
                    return true;
                }
            }
            return false;
        },
        _getXY: function(arg) {
            if (this._isNumber(arg)) {
                return {
                    x: arg,
                    y: arg
                };
            } else if (this._isArray(arg)) {
                if (arg.length === 1) {
                    var val = arg[0];
                    if (this._isNumber(val)) {
                        return {
                            x: val,
                            y: val
                        };
                    } else if (this._isArray(val)) {
                        return {
                            x: val[0],
                            y: val[1]
                        };
                    } else if (this._isObject(val)) {
                        return val;
                    }
                } else if (arg.length >= 2) {
                    return {
                        x: arg[0],
                        y: arg[1]
                    };
                }
            } else if (this._isObject(arg)) {
                return arg;
            }
            return null;
        },
        _getSize: function(arg) {
            if (this._isNumber(arg)) {
                return {
                    width: arg,
                    height: arg
                };
            } else if (this._isArray(arg)) {
                if (arg.length === 1) {
                    var val = arg[0];
                    if (this._isNumber(val)) {
                        return {
                            width: val,
                            height: val
                        };
                    } else if (this._isArray(val)) {
                        if (val.length >= 4) {
                            return {
                                width: val[2],
                                height: val[3]
                            };
                        } else if (val.length >= 2) {
                            return {
                                width: val[0],
                                height: val[1]
                            };
                        }
                    } else if (this._isObject(val)) {
                        return val;
                    }
                } else if (arg.length >= 4) {
                    return {
                        width: arg[2],
                        height: arg[3]
                    };
                } else if (arg.length >= 2) {
                    return {
                        width: arg[0],
                        height: arg[1]
                    };
                }
            } else if (this._isObject(arg)) {
                return arg;
            }
            return null;
        },
        _getPoints: function(arg) {
            if (arg === undefined) {
                return [];
            }
            if (this._isArray(arg[0])) {
                var arr = [];
                for (var n = 0; n < arg.length; n++) {
                    arr.push({
                        x: arg[n][0],
                        y: arg[n][1]
                    });
                }
                return arr;
            }
            if (this._isObject(arg[0])) {
                return arg;
            } else {
                var arr = [];
                for (var n = 0; n < arg.length; n += 2) {
                    arr.push({
                        x: arg[n],
                        y: arg[n + 1]
                    });
                }
                return arr;
            }
        },
        _getImage: function(arg, callback) {
            var imageObj, canvas, context, dataUrl;
            if (!arg) {
                callback(null);
            } else if (this._isElement(arg)) {
                callback(arg);
            } else if (this._isString(arg)) {
                imageObj = new Image();
                imageObj.onload = function() {
                    callback(imageObj);
                };
                imageObj.src = arg;
            } else if (arg.data) {
                canvas = document.createElement(CANVAS);
                canvas.width = arg.width;
                canvas.height = arg.height;
                context = canvas.getContext(CONTEXT_2D);
                context.putImageData(arg, 0, 0);
                dataUrl = canvas.toDataURL();
                imageObj = new Image();
                imageObj.onload = function() {
                    callback(imageObj);
                };
                imageObj.src = dataUrl;
            } else {
                callback(null);
            }
        },
        _rgbToHex: function(r, g, b) {
            return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        },
        _hexToRgb: function(hex) {
            var bigint = parseInt(hex, 16);
            return {
                r: bigint >> 16 & 255,
                g: bigint >> 8 & 255,
                b: bigint & 255
            };
        },
        _getRandomColorKey: function() {
            var randColor = (Math.random() * 16777215 << 0).toString(16);
            while (randColor.length < 6) {
                randColor = "0" + randColor;
            }
            return randColor;
        },
        _merge: function(o1, o2) {
            var retObj = this._clone(o2);
            for (var key in o1) {
                if (this._isObject(o1[key])) {
                    retObj[key] = this._merge(o1[key], retObj[key]);
                } else {
                    retObj[key] = o1[key];
                }
            }
            return retObj;
        },
        _clone: function(obj) {
            var retObj = {};
            for (var key in obj) {
                if (this._isObject(obj[key])) {
                    retObj[key] = this._clone(obj[key]);
                } else {
                    retObj[key] = obj[key];
                }
            }
            return retObj;
        },
        _degToRad: function(deg) {
            return deg * PI_OVER_DEG180;
        },
        _radToDeg: function(rad) {
            return rad * DEG180_OVER_PI;
        },
        _capitalize: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
    };
})();

(function() {
    var canvas = document.createElement("canvas"), context = canvas.getContext("2d"), devicePixelRatio = window.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1, _pixelRatio = devicePixelRatio / backingStoreRatio;
    Kinetic.Canvas = function(config) {
        this.init(config);
    };
    Kinetic.Canvas.prototype = {
        init: function(config) {
            var config = config || {}, width = config.width || 0, height = config.height || 0, pixelRatio = config.pixelRatio || _pixelRatio, contextType = config.contextType || "2d";
            this.pixelRatio = pixelRatio;
            this.width = width;
            this.height = height;
            this.element = document.createElement("canvas");
            this.element.style.padding = 0;
            this.element.style.margin = 0;
            this.element.style.border = 0;
            this.element.style.background = "transparent";
            this.context = this.element.getContext(contextType);
            this.setSize(width, height);
        },
        getElement: function() {
            return this.element;
        },
        getContext: function() {
            return this.context;
        },
        setWidth: function(width) {
            this.width = width;
            this.element.width = width * this.pixelRatio;
            this.element.style.width = width + "px";
        },
        setHeight: function(height) {
            this.height = height;
            this.element.height = height * this.pixelRatio;
            this.element.style.height = height + "px";
        },
        getWidth: function() {
            return this.width;
        },
        getHeight: function() {
            return this.height;
        },
        setSize: function(width, height) {
            this.setWidth(width);
            this.setHeight(height);
        }
    };
    Kinetic.Canvas2D = function(config) {
        Kinetic.Canvas.call(this, config);
    };
    Kinetic.Canvas2D.prototype = {
        clear: function() {
            var context = this.getContext();
            var el = this.getElement();
            context.clearRect(0, 0, el.width, el.height);
        },
        toDataURL: function(mimeType, quality) {
            try {
                return this.element.toDataURL(mimeType, quality);
            } catch (e) {
                try {
                    return this.element.toDataURL();
                } catch (e) {
                    Kinetic.Global.warn("Unable to get data URL. " + e.message);
                    return "";
                }
            }
        },
        fill: function(shape) {
            if (shape.getFillEnabled()) {
                this._fill(shape);
            }
        },
        stroke: function(shape) {
            if (shape.getStrokeEnabled()) {
                this._stroke(shape);
            }
        },
        fillStroke: function(shape) {
            var fillEnabled = shape.getFillEnabled();
            if (fillEnabled) {
                this._fill(shape);
            }
            if (shape.getStrokeEnabled()) {
                this._stroke(shape, shape.hasShadow() && shape.hasFill() && fillEnabled);
            }
        },
        applyShadow: function(shape, drawFunc) {
            var context = this.context;
            context.save();
            this._applyShadow(shape);
            drawFunc();
            context.restore();
            drawFunc();
        },
        _applyLineCap: function(shape) {
            var lineCap = shape.getLineCap();
            if (lineCap) {
                this.context.lineCap = lineCap;
            }
        },
        _applyOpacity: function(shape) {
            var absOpacity = shape.getAbsoluteOpacity();
            if (absOpacity !== 1) {
                this.context.globalAlpha = absOpacity;
            }
        },
        _applyLineJoin: function(shape) {
            var lineJoin = shape.getLineJoin();
            if (lineJoin) {
                this.context.lineJoin = lineJoin;
            }
        },
        _applyAncestorTransforms: function(node) {
            var context = this.context;
            node._eachAncestorReverse(function(no) {
                var t = no.getTransform(), m = t.getMatrix();
                context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            }, true);
        },
        _clip: function(container) {
            var context = this.getContext();
            context.save();
            this._applyAncestorTransforms(container);
            context.beginPath();
            container.getClipFunc()(this);
            context.clip();
            context.setTransform(1, 0, 0, 1, 0, 0);
        }
    };
    Kinetic.Global.extend(Kinetic.Canvas2D, Kinetic.Canvas);
    Kinetic.SceneCanvas = function(config) {
        Kinetic.Canvas2D.call(this, config);
    };
    Kinetic.SceneCanvas.prototype = {
        setWidth: function(width) {
            var pixelRatio = this.pixelRatio;
            Kinetic.Canvas.prototype.setWidth.call(this, width);
            this.context.scale(pixelRatio, pixelRatio);
        },
        setHeight: function(height) {
            var pixelRatio = this.pixelRatio;
            Kinetic.Canvas.prototype.setHeight.call(this, height);
            this.context.scale(pixelRatio, pixelRatio);
        },
        _fillColor: function(shape) {
            var context = this.context, fill = shape.getFill();
            context.fillStyle = fill;
            shape._fillFunc(context);
        },
        _fillPattern: function(shape) {
            var context = this.context, fillPatternImage = shape.getFillPatternImage(), fillPatternX = shape.getFillPatternX(), fillPatternY = shape.getFillPatternY(), fillPatternScale = shape.getFillPatternScale(), fillPatternRotation = shape.getFillPatternRotation(), fillPatternOffset = shape.getFillPatternOffset(), fillPatternRepeat = shape.getFillPatternRepeat();
            if (fillPatternX || fillPatternY) {
                context.translate(fillPatternX || 0, fillPatternY || 0);
            }
            if (fillPatternRotation) {
                context.rotate(fillPatternRotation);
            }
            if (fillPatternScale) {
                context.scale(fillPatternScale.x, fillPatternScale.y);
            }
            if (fillPatternOffset) {
                context.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
            }
            context.fillStyle = context.createPattern(fillPatternImage, fillPatternRepeat || "repeat");
            context.fill();
        },
        _fillLinearGradient: function(shape) {
            var context = this.context, start = shape.getFillLinearGradientStartPoint(), end = shape.getFillLinearGradientEndPoint(), colorStops = shape.getFillLinearGradientColorStops(), grd = context.createLinearGradient(start.x, start.y, end.x, end.y);
            for (var n = 0; n < colorStops.length; n += 2) {
                grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            context.fillStyle = grd;
            context.fill();
        },
        _fillRadialGradient: function(shape) {
            var context = this.context, start = shape.getFillRadialGradientStartPoint(), end = shape.getFillRadialGradientEndPoint(), startRadius = shape.getFillRadialGradientStartRadius(), endRadius = shape.getFillRadialGradientEndRadius(), colorStops = shape.getFillRadialGradientColorStops(), grd = context.createRadialGradient(start.x, start.y, startRadius, end.x, end.y, endRadius);
            for (var n = 0; n < colorStops.length; n += 2) {
                grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            context.fillStyle = grd;
            context.fill();
        },
        _fill: function(shape, skipShadow) {
            var context = this.context, fill = shape.getFill(), fillPatternImage = shape.getFillPatternImage(), fillLinearGradientStartPoint = shape.getFillLinearGradientStartPoint(), fillRadialGradientStartPoint = shape.getFillRadialGradientStartPoint(), fillPriority = shape.getFillPriority();
            context.save();
            if (!skipShadow && shape.hasShadow()) {
                this._applyShadow(shape);
            }
            if (fill && fillPriority === "color") {
                this._fillColor(shape);
            } else if (fillPatternImage && fillPriority === "pattern") {
                this._fillPattern(shape);
            } else if (fillLinearGradientStartPoint && fillPriority === "linear-gradient") {
                this._fillLinearGradient(shape);
            } else if (fillRadialGradientStartPoint && fillPriority === "radial-gradient") {
                this._fillRadialGradient(shape);
            } else if (fill) {
                this._fillColor(shape);
            } else if (fillPatternImage) {
                this._fillPattern(shape);
            } else if (fillLinearGradientStartPoint) {
                this._fillLinearGradient(shape);
            } else if (fillRadialGradientStartPoint) {
                this._fillRadialGradient(shape);
            }
            context.restore();
            if (!skipShadow && shape.hasShadow()) {
                this._fill(shape, true);
            }
        },
        _stroke: function(shape, skipShadow) {
            var context = this.context, stroke = shape.getStroke(), strokeWidth = shape.getStrokeWidth(), dashArray = shape.getDashArray();
            if (stroke || strokeWidth) {
                context.save();
                if (!shape.getStrokeScaleEnabled()) {
                    context.setTransform(1, 0, 0, 1, 0, 0);
                }
                this._applyLineCap(shape);
                if (dashArray && shape.getDashArrayEnabled()) {
                    if (context.setLineDash) {
                        context.setLineDash(dashArray);
                    } else if ("mozDash" in context) {
                        context.mozDash = dashArray;
                    } else if ("webkitLineDash" in context) {
                        context.webkitLineDash = dashArray;
                    }
                }
                if (!skipShadow && shape.hasShadow()) {
                    this._applyShadow(shape);
                }
                context.lineWidth = strokeWidth || 2;
                context.strokeStyle = stroke || "black";
                shape._strokeFunc(context);
                context.restore();
                if (!skipShadow && shape.hasShadow()) {
                    this._stroke(shape, true);
                }
            }
        },
        _applyShadow: function(shape) {
            var context = this.context;
            if (shape.hasShadow() && shape.getShadowEnabled()) {
                var aa = shape.getAbsoluteOpacity();
                var color = shape.getShadowColor() || "black";
                var blur = shape.getShadowBlur() || 5;
                var offset = shape.getShadowOffset() || {
                    x: 0,
                    y: 0
                };
                if (shape.getShadowOpacity()) {
                    context.globalAlpha = shape.getShadowOpacity() * aa;
                }
                context.shadowColor = color;
                context.shadowBlur = blur;
                context.shadowOffsetX = offset.x;
                context.shadowOffsetY = offset.y;
            }
        }
    };
    Kinetic.Global.extend(Kinetic.SceneCanvas, Kinetic.Canvas2D);
    Kinetic.HitCanvas = function(config) {
        Kinetic.Canvas2D.call(this, config);
    };
    Kinetic.HitCanvas.prototype = {
        _fill: function(shape) {
            var context = this.context;
            context.save();
            context.fillStyle = "#" + shape.colorKey;
            shape._fillFuncHit(context);
            context.restore();
        },
        _stroke: function(shape) {
            var context = this.context, stroke = shape.getStroke(), strokeWidth = shape.getStrokeWidth();
            if (stroke || strokeWidth) {
                this._applyLineCap(shape);
                context.save();
                context.lineWidth = strokeWidth || 2;
                context.strokeStyle = "#" + shape.colorKey;
                shape._strokeFuncHit(context);
                context.restore();
            }
        }
    };
    Kinetic.Global.extend(Kinetic.HitCanvas, Kinetic.Canvas2D);
})();

(function() {
    Kinetic.Tween = function(propFunc, func, begin, finish, duration) {
        this._listeners = [];
        this.addListener(this);
        this.propFunc = propFunc;
        this.begin = begin;
        this._pos = begin;
        this.setDuration(duration);
        this.isPlaying = false;
        this._change = 0;
        this.prevTime = 0;
        this.prevPos = 0;
        this.looping = false;
        this._time = 0;
        this._position = 0;
        this._startTime = 0;
        this._finish = 0;
        this.name = "";
        this.func = func;
        this.setFinish(finish);
    };
    Kinetic.Tween.prototype = {
        setTime: function(t) {
            this.prevTime = this._time;
            if (t > this.getDuration()) {
                if (this.looping) {
                    this.rewind(t - this._duration);
                    this.update();
                    this.broadcastMessage("onLooped", {
                        target: this,
                        type: "onLooped"
                    });
                } else {
                    this._time = this._duration;
                    this.update();
                    this.stop();
                    this.broadcastMessage("onFinished", {
                        target: this,
                        type: "onFinished"
                    });
                }
            } else if (t < 0) {
                this.rewind();
                this.update();
            } else {
                this._time = t;
                this.update();
            }
        },
        getTime: function() {
            return this._time;
        },
        setDuration: function(d) {
            this._duration = d === null || d <= 0 ? 1e5 : d;
        },
        getDuration: function() {
            return this._duration;
        },
        setPosition: function(p) {
            this.prevPos = this._pos;
            this.propFunc(p);
            this._pos = p;
            this.broadcastMessage("onChanged", {
                target: this,
                type: "onChanged"
            });
        },
        getPosition: function(t) {
            if (t === undefined) {
                t = this._time;
            }
            return this.func(t, this.begin, this._change, this._duration);
        },
        setFinish: function(f) {
            this._change = f - this.begin;
        },
        getFinish: function() {
            return this.begin + this._change;
        },
        start: function() {
            this.rewind();
            this.startEnterFrame();
            this.broadcastMessage("onStarted", {
                target: this,
                type: "onStarted"
            });
        },
        rewind: function(t) {
            this.stop();
            this._time = t === undefined ? 0 : t;
            this.fixTime();
            this.update();
        },
        fforward: function() {
            this._time = this._duration;
            this.fixTime();
            this.update();
        },
        update: function() {
            this.setPosition(this.getPosition(this._time));
        },
        startEnterFrame: function() {
            this.stopEnterFrame();
            this.isPlaying = true;
            this.onEnterFrame();
        },
        onEnterFrame: function() {
            if (this.isPlaying) {
                this.nextFrame();
            }
        },
        nextFrame: function() {
            this.setTime((this.getTimer() - this._startTime) / 1e3);
        },
        stop: function() {
            this.stopEnterFrame();
            this.broadcastMessage("onStopped", {
                target: this,
                type: "onStopped"
            });
        },
        stopEnterFrame: function() {
            this.isPlaying = false;
        },
        continueTo: function(finish, duration) {
            this.begin = this._pos;
            this.setFinish(finish);
            if (this._duration !== undefined) {
                this.setDuration(duration);
            }
            this.start();
        },
        resume: function() {
            this.fixTime();
            this.startEnterFrame();
            this.broadcastMessage("onResumed", {
                target: this,
                type: "onResumed"
            });
        },
        yoyo: function() {
            this.continueTo(this.begin, this._time);
        },
        addListener: function(o) {
            this.removeListener(o);
            return this._listeners.push(o);
        },
        removeListener: function(o) {
            var a = this._listeners;
            var i = a.length;
            while (i--) {
                if (a[i] == o) {
                    a.splice(i, 1);
                    return true;
                }
            }
            return false;
        },
        broadcastMessage: function() {
            var arr = [];
            for (var i = 0; i < arguments.length; i++) {
                arr.push(arguments[i]);
            }
            var e = arr.shift();
            var a = this._listeners;
            var l = a.length;
            for (var i = 0; i < l; i++) {
                if (a[i][e]) {
                    a[i][e].apply(a[i], arr);
                }
            }
        },
        fixTime: function() {
            this._startTime = this.getTimer() - this._time * 1e3;
        },
        getTimer: function() {
            return new Date().getTime() - this._time;
        }
    };
    Kinetic.Tweens = {
        "back-ease-in": function(t, b, c, d, a, p) {
            var s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        "back-ease-out": function(t, b, c, d, a, p) {
            var s = 1.70158;
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        "back-ease-in-out": function(t, b, c, d, a, p) {
            var s = 1.70158;
            if ((t /= d / 2) < 1) {
                return c / 2 * t * t * (((s *= 1.525) + 1) * t - s) + b;
            }
            return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
        },
        "elastic-ease-in": function(t, b, c, d, a, p) {
            var s = 0;
            if (t === 0) {
                return b;
            }
            if ((t /= d) == 1) {
                return b + c;
            }
            if (!p) {
                p = d * .3;
            }
            if (!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * 2 * Math.PI / p)) + b;
        },
        "elastic-ease-out": function(t, b, c, d, a, p) {
            var s = 0;
            if (t === 0) {
                return b;
            }
            if ((t /= d) == 1) {
                return b + c;
            }
            if (!p) {
                p = d * .3;
            }
            if (!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * 2 * Math.PI / p) + c + b;
        },
        "elastic-ease-in-out": function(t, b, c, d, a, p) {
            var s = 0;
            if (t === 0) {
                return b;
            }
            if ((t /= d / 2) == 2) {
                return b + c;
            }
            if (!p) {
                p = d * .3 * 1.5;
            }
            if (!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            if (t < 1) {
                return -.5 * a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * 2 * Math.PI / p) + b;
            }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * 2 * Math.PI / p) * .5 + c + b;
        },
        "bounce-ease-out": function(t, b, c, d) {
            if ((t /= d) < 1 / 2.75) {
                return c * 7.5625 * t * t + b;
            } else if (t < 2 / 2.75) {
                return c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b;
            } else if (t < 2.5 / 2.75) {
                return c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b;
            } else {
                return c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b;
            }
        },
        "bounce-ease-in": function(t, b, c, d) {
            return c - Kinetic.Tweens["bounce-ease-out"](d - t, 0, c, d) + b;
        },
        "bounce-ease-in-out": function(t, b, c, d) {
            if (t < d / 2) {
                return Kinetic.Tweens["bounce-ease-in"](t * 2, 0, c, d) * .5 + b;
            } else {
                return Kinetic.Tweens["bounce-ease-out"](t * 2 - d, 0, c, d) * .5 + c * .5 + b;
            }
        },
        "ease-in": function(t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        "ease-out": function(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        "ease-in-out": function(t, b, c, d) {
            if ((t /= d / 2) < 1) {
                return c / 2 * t * t + b;
            }
            return -c / 2 * (--t * (t - 2) - 1) + b;
        },
        "strong-ease-in": function(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        "strong-ease-out": function(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        "strong-ease-in-out": function(t, b, c, d) {
            if ((t /= d / 2) < 1) {
                return c / 2 * t * t * t * t * t + b;
            }
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },
        linear: function(t, b, c, d) {
            return c * t / d + b;
        }
    };
})();

(function() {
    Kinetic.Transform = function() {
        this.m = [ 1, 0, 0, 1, 0, 0 ];
    };
    Kinetic.Transform.prototype = {
        translate: function(x, y) {
            this.m[4] += this.m[0] * x + this.m[2] * y;
            this.m[5] += this.m[1] * x + this.m[3] * y;
        },
        scale: function(sx, sy) {
            this.m[0] *= sx;
            this.m[1] *= sx;
            this.m[2] *= sy;
            this.m[3] *= sy;
        },
        rotate: function(rad) {
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var m11 = this.m[0] * c + this.m[2] * s;
            var m12 = this.m[1] * c + this.m[3] * s;
            var m21 = this.m[0] * -s + this.m[2] * c;
            var m22 = this.m[1] * -s + this.m[3] * c;
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
        },
        getTranslation: function() {
            return {
                x: this.m[4],
                y: this.m[5]
            };
        },
        multiply: function(matrix) {
            var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
            var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
            var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
            var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
            var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
            var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            this.m[4] = dx;
            this.m[5] = dy;
        },
        invert: function() {
            var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
            var m0 = this.m[3] * d;
            var m1 = -this.m[1] * d;
            var m2 = -this.m[2] * d;
            var m3 = this.m[0] * d;
            var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
            var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
            this.m[0] = m0;
            this.m[1] = m1;
            this.m[2] = m2;
            this.m[3] = m3;
            this.m[4] = m4;
            this.m[5] = m5;
        },
        getMatrix: function() {
            return this.m;
        }
    };
})();

(function() {
    Kinetic.Collection = function() {
        var args = [].slice.call(arguments), length = args.length, i = 0;
        this.length = length;
        for (;i < length; i++) {
            this[i] = args[i];
        }
        return this;
    };
    Kinetic.Collection.prototype = new Array();
    Kinetic.Collection.prototype.each = function(func) {
        for (var n = 0; n < this.length; n++) {
            func(this[n], n);
        }
    };
    Kinetic.Collection.mapMethods = function(arr) {
        var leng = arr.length, n;
        for (n = 0; n < leng; n++) {
            (function(i) {
                var method = arr[i];
                Kinetic.Collection.prototype[method] = function() {
                    var len = this.length, i;
                    args = [].slice.call(arguments);
                    for (i = 0; i < len; i++) {
                        this[i][method].apply(this[i], args);
                    }
                };
            })(n);
        }
    };
})();

(function() {
    Kinetic.Filters.Grayscale = function(imageData, config) {
        var data = imageData.data;
        for (var i = 0; i < data.length; i += 4) {
            var brightness = .34 * data[i] + .5 * data[i + 1] + .16 * data[i + 2];
            data[i] = brightness;
            data[i + 1] = brightness;
            data[i + 2] = brightness;
        }
    };
})();

(function() {
    Kinetic.Filters.Brighten = function(imageData, config) {
        var brightness = config.val || 0;
        var data = imageData.data;
        for (var i = 0; i < data.length; i += 4) {
            data[i] += brightness;
            data[i + 1] += brightness;
            data[i + 2] += brightness;
        }
    };
})();

(function() {
    Kinetic.Filters.Invert = function(imageData, config) {
        var data = imageData.data;
        for (var i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];
            data[i + 1] = 255 - data[i + 1];
            data[i + 2] = 255 - data[i + 2];
        }
    };
})();

(function(Kinetic) {
    function BlurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    }
    var mul_table = [ 512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259 ];
    var shg_table = [ 9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];
    function filterGaussBlurRGBA(imageData, radius) {
        var pixels = imageData.data, width = imageData.width, height = imageData.height;
        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
        var div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2, stackStart = new BlurStack(), stack = stackStart, stackIn = null, stackOut = null, mul_sum = mul_table[radius], shg_sum = shg_table[radius];
        for (i = 1; i < div; i++) {
            stack = stack.next = new BlurStack();
            if (i == radiusPlus1) var stackEnd = stack;
        }
        stack.next = stackStart;
        yw = yi = 0;
        for (y = 0; y < height; y++) {
            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;
            stack = stackStart;
            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }
            for (i = 1; i < radiusPlus1; i++) {
                p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
                a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;
                stack = stack.next;
            }
            stackIn = stackStart;
            stackOut = stackEnd;
            for (x = 0; x < width; x++) {
                pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
                if (pa != 0) {
                    pa = 255 / pa;
                    pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
                    pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
                    pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
                } else {
                    pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                }
                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;
                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;
                p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
                r_in_sum += stackIn.r = pixels[p];
                g_in_sum += stackIn.g = pixels[p + 1];
                b_in_sum += stackIn.b = pixels[p + 2];
                a_in_sum += stackIn.a = pixels[p + 3];
                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;
                a_sum += a_in_sum;
                stackIn = stackIn.next;
                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;
                a_out_sum += pa = stackOut.a;
                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;
                stackOut = stackOut.next;
                yi += 4;
            }
            yw += width;
        }
        for (x = 0; x < width; x++) {
            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
            yi = x << 2;
            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;
            stack = stackStart;
            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }
            yp = width;
            for (i = 1; i <= radius; i++) {
                yi = yp + x << 2;
                r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
                a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;
                stack = stack.next;
                if (i < heightMinus1) {
                    yp += width;
                }
            }
            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for (y = 0; y < height; y++) {
                p = yi << 2;
                pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
                if (pa > 0) {
                    pa = 255 / pa;
                    pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
                    pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
                    pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa;
                } else {
                    pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
                }
                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;
                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;
                p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
                r_sum += r_in_sum += stackIn.r = pixels[p];
                g_sum += g_in_sum += stackIn.g = pixels[p + 1];
                b_sum += b_in_sum += stackIn.b = pixels[p + 2];
                a_sum += a_in_sum += stackIn.a = pixels[p + 3];
                stackIn = stackIn.next;
                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;
                a_out_sum += pa = stackOut.a;
                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;
                stackOut = stackOut.next;
                yi += width;
            }
        }
    }
    Kinetic = Kinetic || {};
    Kinetic.Filters = Kinetic.Filters || {};
    Kinetic.Filters.Blur = function(imageData, config) {
        var radius = config.radius;
        radius |= 0;
        filterGaussBlurRGBA(imageData, radius);
    };
    window["Kinetic"] = Kinetic;
})(Kinetic);

(function(Kinetic) {
    function pixelAt(idata, x, y) {
        var idx = (y * idata.width + x) * 4;
        var d = [];
        d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
        return d;
    }
    function rgbDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
    }
    function rgbMean(pTab) {
        var m = [ 0, 0, 0 ];
        for (var i = 0; i < pTab.length; i++) {
            m[0] += pTab[i][0];
            m[1] += pTab[i][1];
            m[2] += pTab[i][2];
        }
        m[0] /= pTab.length;
        m[1] /= pTab.length;
        m[2] /= pTab.length;
        return m;
    }
    function backgroundMask(idata, config) {
        var rgbv_no = pixelAt(idata, 0, 0);
        var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
        var rgbv_so = pixelAt(idata, 0, idata.height - 1);
        var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
        var thres = config && config.threshold ? config.threshold : 10;
        if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {
            var mean = rgbMean([ rgbv_ne, rgbv_no, rgbv_se, rgbv_so ]);
            var mask = [];
            for (var i = 0; i < idata.width * idata.height; i++) {
                var d = rgbDistance(mean, [ idata.data[i * 4], idata.data[i * 4 + 1], idata.data[i * 4 + 2] ]);
                mask[i] = d < thres ? 0 : 255;
            }
            return mask;
        }
    }
    function applyMask(idata, mask) {
        for (var i = 0; i < idata.width * idata.height; i++) {
            idata.data[4 * i + 3] = mask[i];
        }
    }
    function erodeMask(mask, sw, sh) {
        var weights = [ 1, 1, 1, 1, 0, 1, 1, 1, 1 ];
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);
        var maskResult = [];
        for (var y = 0; y < sh; y++) {
            for (var x = 0; x < sw; x++) {
                var so = y * sw + x;
                var a = 0;
                for (var cy = 0; cy < side; cy++) {
                    for (var cx = 0; cx < side; cx++) {
                        var scy = y + cy - halfSide;
                        var scx = x + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = scy * sw + scx;
                            var wt = weights[cy * side + cx];
                            a += mask[srcOff] * wt;
                        }
                    }
                }
                maskResult[so] = a === 255 * 8 ? 255 : 0;
            }
        }
        return maskResult;
    }
    function dilateMask(mask, sw, sh) {
        var weights = [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ];
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);
        var maskResult = [];
        for (var y = 0; y < sh; y++) {
            for (var x = 0; x < sw; x++) {
                var so = y * sw + x;
                var a = 0;
                for (var cy = 0; cy < side; cy++) {
                    for (var cx = 0; cx < side; cx++) {
                        var scy = y + cy - halfSide;
                        var scx = x + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = scy * sw + scx;
                            var wt = weights[cy * side + cx];
                            a += mask[srcOff] * wt;
                        }
                    }
                }
                maskResult[so] = a >= 255 * 4 ? 255 : 0;
            }
        }
        return maskResult;
    }
    function smoothEdgeMask(mask, sw, sh) {
        var weights = [ 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9 ];
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);
        var maskResult = [];
        for (var y = 0; y < sh; y++) {
            for (var x = 0; x < sw; x++) {
                var so = y * sw + x;
                var a = 0;
                for (var cy = 0; cy < side; cy++) {
                    for (var cx = 0; cx < side; cx++) {
                        var scy = y + cy - halfSide;
                        var scx = x + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = scy * sw + scx;
                            var wt = weights[cy * side + cx];
                            a += mask[srcOff] * wt;
                        }
                    }
                }
                maskResult[so] = a;
            }
        }
        return maskResult;
    }
    Kinetic = Kinetic || {};
    Kinetic.Filters = Kinetic.Filters || {};
    Kinetic.Filters.Mask = function(idata, config) {
        var mask = backgroundMask(idata, config);
        if (mask) {
            mask = erodeMask(mask, idata.width, idata.height);
            mask = dilateMask(mask, idata.width, idata.height);
            mask = smoothEdgeMask(mask, idata.width, idata.height);
            applyMask(idata, mask);
        }
        return idata;
    };
    window["Kinetic"] = Kinetic;
})(Kinetic);

(function() {
    var SPACE = " ", EMPTY_STRING = "", DOT = ".", GET = "get", SET = "set", SHAPE = "Shape", STAGE = "Stage", X = "x", Y = "y", KINETIC = "kinetic", BEFORE = "before", CHANGE = "Change", ID = "id", NAME = "name", MOUSEENTER = "mouseenter", MOUSELEAVE = "mouseleave", DEG = "Deg", ON = "on", OFF = "off", BEFORE_DRAW = "beforeDraw", DRAW = "draw";
    Kinetic.Node = function(config) {
        this._nodeInit(config);
    };
    Kinetic.Node.prototype = {
        _nodeInit: function(config) {
            this._id = Kinetic.Global.idCounter++;
            this.eventListeners = {};
            this.setAttrs(config);
        },
        on: function(typesStr, handler) {
            var types = typesStr.split(SPACE), len = types.length, n, type, event, parts, baseEvent, name;
            for (n = 0; n < len; n++) {
                type = types[n];
                event = type;
                parts = event.split(DOT);
                baseEvent = parts[0];
                name = parts.length > 1 ? parts[1] : EMPTY_STRING;
                if (!this.eventListeners[baseEvent]) {
                    this.eventListeners[baseEvent] = [];
                }
                this.eventListeners[baseEvent].push({
                    name: name,
                    handler: handler
                });
            }
            return this;
        },
        off: function(typesStr) {
            var types = typesStr.split(SPACE), len = types.length, n, type, event, parts, baseEvent;
            for (n = 0; n < len; n++) {
                type = types[n];
                event = type;
                parts = event.split(DOT);
                baseEvent = parts[0];
                if (parts.length > 1) {
                    if (baseEvent) {
                        if (this.eventListeners[baseEvent]) {
                            this._off(baseEvent, parts[1]);
                        }
                    } else {
                        for (var type in this.eventListeners) {
                            this._off(type, parts[1]);
                        }
                    }
                } else {
                    delete this.eventListeners[baseEvent];
                }
            }
            return this;
        },
        remove: function() {
            var parent = this.getParent();
            if (parent && parent.children) {
                parent.children.splice(this.index, 1);
                parent._setChildrenIndices();
            }
            delete this.parent;
        },
        destroy: function() {
            var parent = this.getParent(), stage = this.getStage(), dd = Kinetic.DD, go = Kinetic.Global;
            while (this.children && this.children.length > 0) {
                this.children[0].destroy();
            }
            go._removeId(this.getId());
            go._removeName(this.getName(), this._id);
            if (this.trans) {
                this.trans.stop();
            }
            this.remove();
        },
        getAttr: function(attr) {
            var method = GET + Kinetic.Type._capitalize(attr);
            return this[method]();
        },
        getAttrs: function() {
            return this.attrs || {};
        },
        createAttrs: function() {
            if (this.attrs === undefined) {
                this.attrs = {};
            }
        },
        setAttrs: function(config) {
            var key, method;
            if (config) {
                for (key in config) {
                    method = SET + Kinetic.Type._capitalize(key);
                    if (Kinetic.Type._isFunction(this[method])) {
                        this[method](config[key]);
                    } else {
                        this.setAttr(key, config[key]);
                    }
                }
            }
        },
        getVisible: function() {
            var visible = this.attrs.visible, parent = this.getParent();
            if (visible === undefined) {
                visible = true;
            }
            if (visible && parent && !parent.getVisible()) {
                return false;
            }
            return visible;
        },
        getListening: function() {
            var listening = this.attrs.listening, parent = this.getParent();
            if (listening === undefined) {
                listening = true;
            }
            if (listening && parent && !parent.getListening()) {
                return false;
            }
            return listening;
        },
        show: function() {
            this.setVisible(true);
        },
        hide: function() {
            this.setVisible(false);
        },
        getZIndex: function() {
            return this.index || 0;
        },
        getAbsoluteZIndex: function() {
            var level = this.getLevel(), stage = this.getStage(), that = this, index = 0, nodes, len, n, child;
            function addChildren(children) {
                nodes = [];
                len = children.length;
                for (n = 0; n < len; n++) {
                    child = children[n];
                    index++;
                    if (child.nodeType !== SHAPE) {
                        nodes = nodes.concat(child.getChildren());
                    }
                    if (child._id === that._id) {
                        n = len;
                    }
                }
                if (nodes.length > 0 && nodes[0].getLevel() <= level) {
                    addChildren(nodes);
                }
            }
            if (that.nodeType !== STAGE) {
                addChildren(that.getStage().getChildren());
            }
            return index;
        },
        getLevel: function() {
            var level = 0, parent = this.parent;
            while (parent) {
                level++;
                parent = parent.parent;
            }
            return level;
        },
        setPosition: function() {
            var pos = Kinetic.Type._getXY([].slice.call(arguments));
            this.setAttr(X, pos.x);
            this.setAttr(Y, pos.y);
        },
        getPosition: function() {
            return {
                x: this.getX(),
                y: this.getY()
            };
        },
        getAbsolutePosition: function() {
            var trans = this.getAbsoluteTransform(), o = this.getOffset();
            trans.translate(o.x, o.y);
            return trans.getTranslation();
        },
        setAbsolutePosition: function() {
            var pos = Kinetic.Type._getXY([].slice.call(arguments)), trans = this._clearTransform(), it;
            this.attrs.x = trans.x;
            this.attrs.y = trans.y;
            delete trans.x;
            delete trans.y;
            it = this.getAbsoluteTransform();
            it.invert();
            it.translate(pos.x, pos.y);
            pos = {
                x: this.attrs.x + it.getTranslation().x,
                y: this.attrs.y + it.getTranslation().y
            };
            this.setPosition(pos.x, pos.y);
            this._setTransform(trans);
        },
        move: function() {
            var pos = Kinetic.Type._getXY([].slice.call(arguments)), x = this.getX(), y = this.getY();
            if (pos.x !== undefined) {
                x += pos.x;
            }
            if (pos.y !== undefined) {
                y += pos.y;
            }
            this.setPosition(x, y);
        },
        _eachAncestorReverse: function(func, includeSelf) {
            var family = [], parent = this.getParent(), len, n;
            if (includeSelf) {
                family.unshift(this);
            }
            while (parent) {
                family.unshift(parent);
                parent = parent.parent;
            }
            len = family.length;
            for (n = 0; n < len; n++) {
                func(family[n]);
            }
        },
        rotate: function(theta) {
            this.setRotation(this.getRotation() + theta);
        },
        rotateDeg: function(deg) {
            this.setRotation(this.getRotation() + Kinetic.Type._degToRad(deg));
        },
        moveToTop: function() {
            var index = this.index;
            this.parent.children.splice(index, 1);
            this.parent.children.push(this);
            this.parent._setChildrenIndices();
            return true;
        },
        moveUp: function() {
            var index = this.index, len = this.parent.getChildren().length;
            if (index < len - 1) {
                this.parent.children.splice(index, 1);
                this.parent.children.splice(index + 1, 0, this);
                this.parent._setChildrenIndices();
                return true;
            }
        },
        moveDown: function() {
            var index = this.index;
            if (index > 0) {
                this.parent.children.splice(index, 1);
                this.parent.children.splice(index - 1, 0, this);
                this.parent._setChildrenIndices();
                return true;
            }
        },
        moveToBottom: function() {
            var index = this.index;
            if (index > 0) {
                this.parent.children.splice(index, 1);
                this.parent.children.unshift(this);
                this.parent._setChildrenIndices();
                return true;
            }
        },
        setZIndex: function(zIndex) {
            var index = this.index;
            this.parent.children.splice(index, 1);
            this.parent.children.splice(zIndex, 0, this);
            this.parent._setChildrenIndices();
        },
        getAbsoluteOpacity: function() {
            var absOpacity = this.getOpacity();
            if (this.getParent()) {
                absOpacity *= this.getParent().getAbsoluteOpacity();
            }
            return absOpacity;
        },
        moveTo: function(newContainer) {
            Kinetic.Node.prototype.remove.call(this);
            newContainer.add(this);
        },
        toObject: function() {
            var type = Kinetic.Type, obj = {}, attrs = this.getAttrs(), key, val;
            obj.attrs = {};
            for (key in attrs) {
                val = attrs[key];
                if (!type._isFunction(val) && !type._isElement(val) && !(type._isObject(val) && type._hasMethods(val))) {
                    obj.attrs[key] = val;
                }
            }
            obj.nodeType = this.nodeType;
            obj.shapeType = this.shapeType;
            return obj;
        },
        toJSON: function() {
            return JSON.stringify(this.toObject());
        },
        getParent: function() {
            return this.parent;
        },
        getLayer: function() {
            return this.getParent().getLayer();
        },
        getStage: function() {
            if (this.getParent()) {
                return this.getParent().getStage();
            } else {
                return undefined;
            }
        },
        fire: function(eventType, evt, preventBubble) {
            if (preventBubble) {
                this._executeHandlers(eventType, evt || {});
            } else {
                this._handleEvent(eventType, evt || {});
            }
        },
        getAbsoluteTransform: function() {
            var am = new Kinetic.Transform(), m;
            this._eachAncestorReverse(function(node) {
                m = node.getTransform();
                am.multiply(m);
            }, true);
            return am;
        },
        getTransform: function() {
            var m = new Kinetic.Transform(), x = this.getX(), y = this.getY(), rotation = this.getRotation(), scale = this.getScale(), scaleX = scale.x, scaleY = scale.y, offset = this.getOffset(), offsetX = offset.x, offsetY = offset.y;
            if (x !== 0 || y !== 0) {
                m.translate(x, y);
            }
            if (rotation !== 0) {
                m.rotate(rotation);
            }
            if (scaleX !== 1 || scaleY !== 1) {
                m.scale(scaleX, scaleY);
            }
            if (offsetX !== 0 || offsetY !== 0) {
                m.translate(-1 * offsetX, -1 * offsetY);
            }
            return m;
        },
        clone: function(obj) {
            var classType = this.shapeType || this.nodeType, node = new Kinetic[classType](this.attrs), key, allListeners, len, n, listener;
            for (key in this.eventListeners) {
                allListeners = this.eventListeners[key];
                len = allListeners.length;
                for (n = 0; n < len; n++) {
                    listener = allListeners[n];
                    if (listener.name.indexOf(KINETIC) < 0) {
                        if (!node.eventListeners[key]) {
                            node.eventListeners[key] = [];
                        }
                        node.eventListeners[key].push(listener);
                    }
                }
            }
            node.setAttrs(obj);
            return node;
        },
        toDataURL: function(config) {
            var config = config || {}, mimeType = config.mimeType || null, quality = config.quality || null, stage = this.getStage(), x = config.x || 0, y = config.y || 0, canvas = new Kinetic.SceneCanvas({
                width: config.width || stage.getWidth(),
                height: config.height || stage.getHeight(),
                pixelRatio: 1
            }), context = canvas.getContext();
            context.save();
            if (x || y) {
                context.translate(-1 * x, -1 * y);
            }
            this.drawScene(canvas);
            context.restore();
            return canvas.toDataURL(mimeType, quality);
        },
        toImage: function(config) {
            Kinetic.Type._getImage(this.toDataURL(config), function(img) {
                config.callback(img);
            });
        },
        setSize: function() {
            var size = Kinetic.Type._getSize(Array.prototype.slice.call(arguments));
            this.setWidth(size.width);
            this.setHeight(size.height);
        },
        getSize: function() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            };
        },
        getWidth: function() {
            return this.attrs.width || 0;
        },
        getHeight: function() {
            return this.attrs.height || 0;
        },
        _get: function(selector) {
            return this.nodeType === selector ? [ this ] : [];
        },
        _off: function(type, name) {
            var evtListeners = this.eventListeners[type], i;
            for (i = 0; i < evtListeners.length; i++) {
                if (evtListeners[i].name === name) {
                    evtListeners.splice(i, 1);
                    if (evtListeners.length === 0) {
                        delete this.eventListeners[type];
                        break;
                    }
                    i--;
                }
            }
        },
        _clearTransform: function() {
            var scale = this.getScale(), offset = this.getOffset(), trans = {
                x: this.getX(),
                y: this.getY(),
                rotation: this.getRotation(),
                scale: {
                    x: scale.x,
                    y: scale.y
                },
                offset: {
                    x: offset.x,
                    y: offset.y
                }
            };
            this.attrs.x = 0;
            this.attrs.y = 0;
            this.attrs.rotation = 0;
            this.attrs.scale = {
                x: 1,
                y: 1
            };
            this.attrs.offset = {
                x: 0,
                y: 0
            };
            return trans;
        },
        _setTransform: function(trans) {
            var key;
            for (key in trans) {
                this.attrs[key] = trans[key];
            }
        },
        _fireBeforeChangeEvent: function(attr, oldVal, newVal) {
            this._handleEvent(BEFORE + Kinetic.Type._capitalize(attr) + CHANGE, {
                oldVal: oldVal,
                newVal: newVal
            });
        },
        _fireChangeEvent: function(attr, oldVal, newVal) {
            this._handleEvent(attr + CHANGE, {
                oldVal: oldVal,
                newVal: newVal
            });
        },
        setId: function(id) {
            var oldId = this.getId(), stage = this.getStage(), go = Kinetic.Global;
            go._removeId(oldId);
            go._addId(this, id);
            this.setAttr(ID, id);
        },
        setName: function(name) {
            var oldName = this.getName(), stage = this.getStage(), go = Kinetic.Global;
            go._removeName(oldName, this._id);
            go._addName(this, name);
            this.setAttr(NAME, name);
        },
        getNodeType: function() {
            return this.nodeType;
        },
        setAttr: function(key, val) {
            var oldVal;
            if (val !== undefined) {
                oldVal = this.attrs[key];
                this._fireBeforeChangeEvent(key, oldVal, val);
                this.attrs[key] = val;
                this._fireChangeEvent(key, oldVal, val);
            }
        },
        _handleEvent: function(eventType, evt, compareShape) {
            if (evt && this.nodeType === SHAPE) {
                evt.targetNode = this;
            }
            var stage = this.getStage();
            var el = this.eventListeners;
            var okayToRun = true;
            if (eventType === MOUSEENTER && compareShape && this._id === compareShape._id) {
                okayToRun = false;
            } else if (eventType === MOUSELEAVE && compareShape && this._id === compareShape._id) {
                okayToRun = false;
            }
            if (okayToRun) {
                this._executeHandlers(eventType, evt);
                if (evt && !evt.cancelBubble && this.parent) {
                    if (compareShape && compareShape.parent) {
                        this._handleEvent.call(this.parent, eventType, evt, compareShape.parent);
                    } else {
                        this._handleEvent.call(this.parent, eventType, evt);
                    }
                }
            }
        },
        _executeHandlers: function(eventType, evt) {
            var events = this.eventListeners[eventType], len, i;
            if (events) {
                len = events.length;
                for (i = 0; i < len; i++) {
                    events[i].handler.apply(this, [ evt ]);
                }
            }
        },
        draw: function() {
            var evt = {
                node: this
            };
            this.fire(BEFORE_DRAW, evt);
            this.drawScene();
            this.drawHit();
            this.fire(DRAW, evt);
        },
        shouldDrawHit: function() {
            return this.isVisible() && this.isListening() && !Kinetic.Global.isDragging();
        }
    };
    Kinetic.Node.addGetterSetter = function(constructor, arr, def) {
        this.addGetter(constructor, arr, def);
        this.addSetter(constructor, arr);
    };
    Kinetic.Node.addPointGetterSetter = function(constructor, arr, def) {
        this.addGetter(constructor, arr, def);
        this.addPointSetter(constructor, arr);
    };
    Kinetic.Node.addRotationGetterSetter = function(constructor, arr, def) {
        this.addRotationGetter(constructor, arr, def);
        this.addRotationSetter(constructor, arr);
    };
    Kinetic.Node.addSetter = function(constructor, attr) {
        var that = this, method = SET + Kinetic.Type._capitalize(attr);
        constructor.prototype[method] = function(val) {
            this.setAttr(attr, val);
        };
    };
    Kinetic.Node.addPointSetter = function(constructor, attr) {
        var that = this, method = SET + Kinetic.Type._capitalize(attr);
        constructor.prototype[method] = function() {
            var pos = Kinetic.Type._getXY([].slice.call(arguments));
            if (!this.attrs[attr]) {
                this.attrs[attr] = {
                    x: 1,
                    y: 1
                };
            }
            if (pos && pos.x === undefined) {
                pos.x = this.attrs[attr].x;
            }
            if (pos && pos.y === undefined) {
                pos.y = this.attrs[attr].y;
            }
            this.setAttr(attr, pos);
        };
    };
    Kinetic.Node.addRotationSetter = function(constructor, attr) {
        var that = this, method = SET + Kinetic.Type._capitalize(attr);
        constructor.prototype[method] = function(val) {
            this.setAttr(attr, val);
        };
        constructor.prototype[method + DEG] = function(deg) {
            this.setAttr(attr, Kinetic.Type._degToRad(deg));
        };
    };
    Kinetic.Node.addGetter = function(constructor, attr, def) {
        var that = this, method = GET + Kinetic.Type._capitalize(attr);
        constructor.prototype[method] = function(arg) {
            var val = this.attrs[attr];
            if (val === undefined) {
                val = def;
            }
            return val;
        };
    };
    Kinetic.Node.addRotationGetter = function(constructor, attr, def) {
        var that = this, method = GET + Kinetic.Type._capitalize(attr);
        constructor.prototype[method] = function() {
            var val = this.attrs[attr];
            if (val === undefined) {
                val = def;
            }
            return val;
        };
        constructor.prototype[method + DEG] = function() {
            var val = this.attrs[attr];
            if (val === undefined) {
                val = def;
            }
            return Kinetic.Type._radToDeg(val);
        };
    };
    Kinetic.Node.create = function(json, container) {
        return this._createNode(JSON.parse(json), container);
    };
    Kinetic.Node._createNode = function(obj, container) {
        var type, no, len, n;
        if (obj.nodeType === SHAPE) {
            if (obj.shapeType === undefined) {
                type = SHAPE;
            } else {
                type = obj.shapeType;
            }
        } else {
            type = obj.nodeType;
        }
        if (container) {
            obj.attrs.container = container;
        }
        no = new Kinetic[type](obj.attrs);
        if (obj.children) {
            len = obj.children.length;
            for (n = 0; n < len; n++) {
                no.add(this._createNode(obj.children[n]));
            }
        }
        return no;
    };
    Kinetic.Node.addGetterSetter(Kinetic.Node, "x", 0);
    Kinetic.Node.addGetterSetter(Kinetic.Node, "y", 0);
    Kinetic.Node.addGetterSetter(Kinetic.Node, "opacity", 1);
    Kinetic.Node.addGetter(Kinetic.Node, "name");
    Kinetic.Node.addGetter(Kinetic.Node, "id");
    Kinetic.Node.addRotationGetterSetter(Kinetic.Node, "rotation", 0);
    Kinetic.Node.addPointGetterSetter(Kinetic.Node, "scale", {
        x: 1,
        y: 1
    });
    Kinetic.Node.addPointGetterSetter(Kinetic.Node, "offset", {
        x: 0,
        y: 0
    });
    Kinetic.Node.addSetter(Kinetic.Node, "width");
    Kinetic.Node.addSetter(Kinetic.Node, "height");
    Kinetic.Node.addSetter(Kinetic.Node, "listening");
    Kinetic.Node.addSetter(Kinetic.Node, "visible");
    Kinetic.Node.prototype.isListening = Kinetic.Node.prototype.getListening;
    Kinetic.Node.prototype.isVisible = Kinetic.Node.prototype.getVisible;
    Kinetic.Collection.mapMethods([ "on", "off" ]);
})();

(function() {
    Kinetic.Animation = function(func, node) {
        this.func = func;
        this.node = node;
        this.id = Kinetic.Animation.animIdCounter++;
        this.frame = {
            time: 0,
            timeDiff: 0,
            lastTime: new Date().getTime()
        };
    };
    Kinetic.Animation.prototype = {
        isRunning: function() {
            var a = Kinetic.Animation, animations = a.animations;
            for (var n = 0; n < animations.length; n++) {
                if (animations[n].id === this.id) {
                    return true;
                }
            }
            return false;
        },
        start: function() {
            this.stop();
            this.frame.timeDiff = 0;
            this.frame.lastTime = new Date().getTime();
            Kinetic.Animation._addAnimation(this);
        },
        stop: function() {
            Kinetic.Animation._removeAnimation(this);
        },
        _updateFrameObject: function(time) {
            this.frame.timeDiff = time - this.frame.lastTime;
            this.frame.lastTime = time;
            this.frame.time += this.frame.timeDiff;
            this.frame.frameRate = 1e3 / this.frame.timeDiff;
        }
    };
    Kinetic.Animation.animations = [];
    Kinetic.Animation.animIdCounter = 0;
    Kinetic.Animation.animRunning = false;
    Kinetic.Animation.fixedRequestAnimFrame = function(callback) {
        window.setTimeout(callback, 1e3 / 60);
    };
    Kinetic.Animation._addAnimation = function(anim) {
        this.animations.push(anim);
        this._handleAnimation();
    };
    Kinetic.Animation._removeAnimation = function(anim) {
        var id = anim.id, animations = this.animations, len = animations.length;
        for (var n = 0; n < len; n++) {
            if (animations[n].id === id) {
                this.animations.splice(n, 1);
                break;
            }
        }
    };
    Kinetic.Animation._runFrames = function() {
        var nodes = {}, animations = this.animations;
        for (var n = 0; n < animations.length; n++) {
            var anim = animations[n], node = anim.node, func = anim.func;
            anim._updateFrameObject(new Date().getTime());
            if (node && node._id !== undefined) {
                nodes[node._id] = node;
            }
            if (func) {
                func(anim.frame);
            }
        }
        for (var key in nodes) {
            nodes[key].draw();
        }
    };
    Kinetic.Animation._animationLoop = function() {
        var that = this;
        if (this.animations.length > 0) {
            this._runFrames();
            Kinetic.Animation.requestAnimFrame(function() {
                that._animationLoop();
            });
        } else {
            this.animRunning = false;
        }
    };
    Kinetic.Animation._handleAnimation = function() {
        var that = this;
        if (!this.animRunning) {
            this.animRunning = true;
            that._animationLoop();
        }
    };
    RAF = function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || Kinetic.Animation.fixedRequestAnimFrame;
    }();
    Kinetic.Animation.requestAnimFrame = function(callback) {
        var raf = Kinetic.DD && Kinetic.DD.isDragging ? this.fixedRequestAnimFrame : RAF;
        raf(callback);
    };
    var moveTo = Kinetic.Node.prototype.moveTo;
    Kinetic.Node.prototype.moveTo = function(container) {
        moveTo.call(this, container);
    };
})();

(function() {
    Kinetic.DD = {
        anim: new Kinetic.Animation(),
        isDragging: false,
        offset: {
            x: 0,
            y: 0
        },
        node: null,
        _drag: function(evt) {
            var dd = Kinetic.DD, node = dd.node;
            if (node) {
                var pos = node.getStage().getPointerPosition();
                var dbf = node.getDragBoundFunc();
                var newNodePos = {
                    x: pos.x - dd.offset.x,
                    y: pos.y - dd.offset.y
                };
                if (dbf !== undefined) {
                    newNodePos = dbf.call(node, newNodePos, evt);
                }
                node.setAbsolutePosition(newNodePos);
                if (!dd.isDragging) {
                    dd.isDragging = true;
                    node._handleEvent("dragstart", evt);
                }
                node._handleEvent("dragmove", evt);
            }
        },
        _endDragBefore: function(evt) {
            var dd = Kinetic.DD, node = dd.node, nodeType, layer;
            if (node) {
                nodeType = node.nodeType, layer = node.getLayer();
                dd.anim.stop();
                if (dd.isDragging) {
                    dd.isDragging = false;
                    if (evt) {
                        evt.dragEndNode = node;
                    }
                }
                delete dd.node;
                (layer || node).draw();
            }
        },
        _endDragAfter: function(evt) {
            var evt = evt || {}, dragEndNode = evt.dragEndNode;
            if (evt && dragEndNode) {
                dragEndNode._handleEvent("dragend", evt);
            }
        }
    };
    Kinetic.Node.prototype.startDrag = function() {
        var dd = Kinetic.DD, that = this, stage = this.getStage(), layer = this.getLayer(), pos = stage.getPointerPosition(), m = this.getTransform().getTranslation(), ap = this.getAbsolutePosition(), animNode = layer || this;
        if (pos) {
            if (dd.node) {
                dd.node.stopDrag();
            }
            dd.node = this;
            dd.offset.x = pos.x - ap.x;
            dd.offset.y = pos.y - ap.y;
            dd.anim.node = animNode;
            dd.anim.start();
        }
    };
    Kinetic.Node.prototype.stopDrag = function() {
        var dd = Kinetic.DD, evt = {};
        dd._endDragBefore(evt);
        dd._endDragAfter(evt);
    };
    Kinetic.Node.prototype.setDraggable = function(draggable) {
        this.setAttr("draggable", draggable);
        this._dragChange();
    };
    var origDestroy = Kinetic.Node.prototype.destroy;
    Kinetic.Node.prototype.destroy = function() {
        var dd = Kinetic.DD;
        if (dd.node && dd.node._id === this._id) {
            this.stopDrag();
        }
        origDestroy.call(this);
    };
    Kinetic.Node.prototype.isDragging = function() {
        var dd = Kinetic.DD;
        return dd.node && dd.node._id === this._id && dd.isDragging;
    };
    Kinetic.Node.prototype._listenDrag = function() {
        this._dragCleanup();
        var that = this;
        this.on("mousedown.kinetic touchstart.kinetic", function(evt) {
            if (!Kinetic.DD.node) {
                that.startDrag(evt);
            }
        });
    };
    Kinetic.Node.prototype._dragChange = function() {
        if (this.attrs.draggable) {
            this._listenDrag();
        } else {
            this._dragCleanup();
            var stage = this.getStage();
            var dd = Kinetic.DD;
            if (stage && dd.node && dd.node._id === this._id) {
                dd.node.stopDrag();
            }
        }
    };
    Kinetic.Node.prototype._dragCleanup = function() {
        this.off("mousedown.kinetic");
        this.off("touchstart.kinetic");
    };
    Kinetic.Node.addGetterSetter(Kinetic.Node, "dragBoundFunc");
    Kinetic.Node.addGetterSetter(Kinetic.Node, "dragOnTop", true);
    Kinetic.Node.addGetter(Kinetic.Node, "draggable", false);
    Kinetic.Node.prototype.isDraggable = Kinetic.Node.prototype.getDraggable;
    var html = document.getElementsByTagName("html")[0];
    html.addEventListener("mouseup", Kinetic.DD._endDragBefore, true);
    html.addEventListener("touchend", Kinetic.DD._endDragBefore, true);
    html.addEventListener("mouseup", Kinetic.DD._endDragAfter, false);
    html.addEventListener("touchend", Kinetic.DD._endDragAfter, false);
})();

(function() {
    function createTween(obj, key, easingFunc, start, end, duration) {
        var tween = new Kinetic.Tween(function(i) {
            obj[key] = i;
        }, easingFunc, start, end, duration);
        return tween;
    }
    Kinetic.Transition = function(node, config) {
        var that = this, easing = config.easing || "linear", easingFunc = Kinetic.Tweens[easing], duration = config.duration || 0, configVal = null, lastTweenIndex = 0, obj = {}, x = 0, y = 0;
        this.tweens = [];
        this.attrs = {};
        this.node = node;
        for (var key in config) {
            if (key !== "duration" && key !== "easing" && key !== "callback") {
                configVal = config[key];
                obj = node.getAttr(key);
                if (Kinetic.Type._isObject(obj)) {
                    configValX = configVal.x;
                    configValY = configVal.y;
                    this.attrs[key] = {};
                    if (configValX !== undefined) {
                        that.tweens.push(createTween(this.attrs[key], "x", easingFunc, obj.x, configValX, duration));
                    }
                    if (configValY !== undefined) {
                        that.tweens.push(createTween(this.attrs[key], "y", easingFunc, obj.y, configValY, duration));
                    }
                } else {
                    that.tweens.push(createTween(this.attrs, key, easingFunc, node.getAttr(key), configVal, duration));
                }
            }
        }
        lastTweenIndex = this.tweens.length - 1;
        this.tweens[lastTweenIndex].onStarted = function() {};
        this.tweens[lastTweenIndex].onStopped = function() {
            node.transAnim.stop();
        };
        this.tweens[lastTweenIndex].onResumed = function() {
            node.transAnim.start();
        };
        this.tweens[lastTweenIndex].onLooped = function() {};
        this.tweens[lastTweenIndex].onChanged = function() {};
        this.tweens[lastTweenIndex].onFinished = function() {
            var newAttrs = {};
            for (var key in config) {
                if (key !== "duration" && key !== "easing" && key !== "callback") {
                    newAttrs[key] = config[key];
                }
            }
            node.transAnim.stop();
            node.setAttrs(newAttrs);
            if (config.callback) {
                config.callback.call(node);
            }
        };
    };
    Kinetic.Transition.prototype = {
        start: function() {
            for (var n = 0; n < this.tweens.length; n++) {
                this.tweens[n].start();
            }
        },
        stop: function() {
            for (var n = 0; n < this.tweens.length; n++) {
                this.tweens[n].stop();
            }
        },
        resume: function() {
            for (var n = 0; n < this.tweens.length; n++) {
                this.tweens[n].resume();
            }
        },
        _onEnterFrame: function() {
            for (var n = 0; n < this.tweens.length; n++) {
                this.tweens[n].onEnterFrame();
            }
            this.node.setAttrs(this.attrs);
        },
        _add: function(tween) {
            this.tweens.push(tween);
        }
    };
    Kinetic.Node.prototype.transitionTo = function(config) {
        var that = this, trans = new Kinetic.Transition(this, config);
        if (!this.transAnim) {
            this.transAnim = new Kinetic.Animation();
        }
        this.transAnim.func = function() {
            trans._onEnterFrame();
        };
        this.transAnim.node = this.nodeType === "Stage" ? this : this.getLayer();
        trans.start();
        this.transAnim.start();
        this.trans = trans;
        return trans;
    };
})();

(function() {
    Kinetic.Container = function(config) {
        this._containerInit(config);
    };
    Kinetic.Container.prototype = {
        _containerInit: function(config) {
            this.children = [];
            Kinetic.Node.call(this, config);
        },
        getChildren: function() {
            return this.children;
        },
        removeChildren: function() {
            while (this.children.length > 0) {
                this.children[0].remove();
            }
        },
        add: function(child) {
            var go = Kinetic.Global, children = this.children;
            child.index = children.length;
            child.parent = this;
            children.push(child);
            return this;
        },
        get: function(selector) {
            var collection = new Kinetic.Collection();
            if (selector.charAt(0) === "#") {
                var node = this._getNodeById(selector.slice(1));
                if (node) {
                    collection.push(node);
                }
            } else if (selector.charAt(0) === ".") {
                var nodeList = this._getNodesByName(selector.slice(1));
                Kinetic.Collection.apply(collection, nodeList);
            } else {
                var retArr = [];
                var children = this.getChildren();
                var len = children.length;
                for (var n = 0; n < len; n++) {
                    retArr = retArr.concat(children[n]._get(selector));
                }
                Kinetic.Collection.apply(collection, retArr);
            }
            return collection;
        },
        _getNodeById: function(key) {
            var stage = this.getStage(), go = Kinetic.Global, node = go.ids[key];
            if (node !== undefined && this.isAncestorOf(node)) {
                return node;
            }
            return null;
        },
        _getNodesByName: function(key) {
            var go = Kinetic.Global, arr = go.names[key] || [];
            return this._getDescendants(arr);
        },
        _get: function(selector) {
            var retArr = Kinetic.Node.prototype._get.call(this, selector);
            var children = this.getChildren();
            var len = children.length;
            for (var n = 0; n < len; n++) {
                retArr = retArr.concat(children[n]._get(selector));
            }
            return retArr;
        },
        toObject: function() {
            var obj = Kinetic.Node.prototype.toObject.call(this);
            obj.children = [];
            var children = this.getChildren();
            var len = children.length;
            for (var n = 0; n < len; n++) {
                var child = children[n];
                obj.children.push(child.toObject());
            }
            return obj;
        },
        _getDescendants: function(arr) {
            var retArr = [];
            var len = arr.length;
            for (var n = 0; n < len; n++) {
                var node = arr[n];
                if (this.isAncestorOf(node)) {
                    retArr.push(node);
                }
            }
            return retArr;
        },
        isAncestorOf: function(node) {
            var parent = node.getParent();
            while (parent) {
                if (parent._id === this._id) {
                    return true;
                }
                parent = parent.getParent();
            }
            return false;
        },
        clone: function(obj) {
            var node = Kinetic.Node.prototype.clone.call(this, obj);
            for (var key in this.children) {
                node.add(this.children[key].clone());
            }
            return node;
        },
        getIntersections: function() {
            var pos = Kinetic.Type._getXY(Array.prototype.slice.call(arguments));
            var arr = [];
            var shapes = this.get("Shape");
            var len = shapes.length;
            for (var n = 0; n < len; n++) {
                var shape = shapes[n];
                if (shape.isVisible() && shape.intersects(pos)) {
                    arr.push(shape);
                }
            }
            return arr;
        },
        _setChildrenIndices: function() {
            var children = this.children, len = children.length;
            for (var n = 0; n < len; n++) {
                children[n].index = n;
            }
        },
        drawScene: function(canvas) {
            var layer = this.getLayer(), clip = !!this.getClipFunc(), stage = this.getStage(), children, len;
            if (!canvas && layer) {
                canvas = layer.getCanvas();
            }
            if (this.isVisible()) {
                if (clip) {
                    canvas._clip(this);
                }
                children = this.children;
                len = children.length;
                for (var n = 0; n < len; n++) {
                    children[n].drawScene(canvas);
                }
                if (clip) {
                    canvas.getContext().restore();
                }
            }
        },
        drawHit: function() {
            var clip = !!this.getClipFunc() && this.nodeType !== "Stage", n = 0, len = 0, children = [], hitCanvas;
            if (this.shouldDrawHit()) {
                if (clip) {
                    hitCanvas = this.getLayer().hitCanvas;
                    hitCanvas._clip(this);
                }
                children = this.children;
                len = children.length;
                for (n = 0; n < len; n++) {
                    children[n].drawHit();
                }
                if (clip) {
                    hitCanvas.getContext().restore();
                }
            }
        }
    };
    Kinetic.Global.extend(Kinetic.Container, Kinetic.Node);
    Kinetic.Node.addGetterSetter(Kinetic.Container, "clipFunc");
})();

(function() {
    Kinetic.Shape = function(config) {
        this._initShape(config);
    };
    function _fillFunc(context) {
        context.fill();
    }
    function _strokeFunc(context) {
        context.stroke();
    }
    function _fillFuncHit(context) {
        context.fill();
    }
    function _strokeFuncHit(context) {
        context.stroke();
    }
    Kinetic.Shape.prototype = {
        _initShape: function(config) {
            this.nodeType = "Shape";
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this._fillFuncHit = _fillFuncHit;
            this._strokeFuncHit = _strokeFuncHit;
            var shapes = Kinetic.Global.shapes;
            var key;
            while (true) {
                key = Kinetic.Type._getRandomColorKey();
                if (key && !(key in shapes)) {
                    break;
                }
            }
            this.colorKey = key;
            shapes[key] = this;
            this.createAttrs();
            Kinetic.Node.call(this, config);
        },
        getContext: function() {
            return this.getLayer().getContext();
        },
        getCanvas: function() {
            return this.getLayer().getCanvas();
        },
        hasShadow: function() {
            return !!(this.getShadowColor() || this.getShadowBlur() || this.getShadowOffset());
        },
        hasFill: function() {
            return !!(this.getFill() || this.getFillPatternImage() || this.getFillLinearGradientStartPoint() || this.getFillRadialGradientStartPoint());
        },
        _get: function(selector) {
            return this.nodeType === selector || this.shapeType === selector ? [ this ] : [];
        },
        intersects: function() {
            var pos = Kinetic.Type._getXY(Array.prototype.slice.call(arguments));
            var stage = this.getStage();
            var hitCanvas = stage.hitCanvas;
            hitCanvas.clear();
            this.drawScene(hitCanvas);
            var p = hitCanvas.context.getImageData(pos.x | 0, pos.y | 0, 1, 1).data;
            return p[3] > 0;
        },
        enableFill: function() {
            this.setAttr("fillEnabled", true);
        },
        disableFill: function() {
            this.setAttr("fillEnabled", false);
        },
        enableStroke: function() {
            this.setAttr("strokeEnabled", true);
        },
        disableStroke: function() {
            this.setAttr("strokeEnabled", false);
        },
        enableStrokeScale: function() {
            this.setAttr("strokeScaleEnabled", true);
        },
        disableStrokeScale: function() {
            this.setAttr("strokeScaleEnabled", false);
        },
        enableShadow: function() {
            this.setAttr("shadowEnabled", true);
        },
        disableShadow: function() {
            this.setAttr("shadowEnabled", false);
        },
        enableDashArray: function() {
            this.setAttr("dashArrayEnabled", true);
        },
        disableDashArray: function() {
            this.setAttr("dashArrayEnabled", false);
        },
        getShapeType: function() {
            return this.shapeType;
        },
        destroy: function() {
            Kinetic.Node.prototype.destroy.call(this);
            delete Kinetic.Global.shapes[this.colorKey];
        },
        drawScene: function(canvas) {
            var attrs = this.getAttrs(), drawFunc = attrs.drawFunc, canvas = canvas || this.getLayer().getCanvas(), context = canvas.getContext();
            if (drawFunc && this.isVisible()) {
                context.save();
                canvas._applyOpacity(this);
                canvas._applyLineJoin(this);
                canvas._applyAncestorTransforms(this);
                drawFunc.call(this, canvas);
                context.restore();
            }
        },
        drawHit: function() {
            var attrs = this.getAttrs(), drawFunc = attrs.drawHitFunc || attrs.drawFunc, canvas = this.getLayer().hitCanvas, context = canvas.getContext();
            if (drawFunc && this.shouldDrawHit()) {
                context.save();
                canvas._applyLineJoin(this);
                canvas._applyAncestorTransforms(this);
                drawFunc.call(this, canvas);
                context.restore();
            }
        },
        _setDrawFuncs: function() {
            if (!this.attrs.drawFunc && this.drawFunc) {
                this.setDrawFunc(this.drawFunc);
            }
            if (!this.attrs.drawHitFunc && this.drawHitFunc) {
                this.setDrawHitFunc(this.drawHitFunc);
            }
        }
    };
    Kinetic.Global.extend(Kinetic.Shape, Kinetic.Node);
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "stroke");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "lineJoin");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "lineCap");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "strokeWidth");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "drawFunc");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "drawHitFunc");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "dashArray");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "shadowColor");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "shadowBlur");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "shadowOpacity");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillPatternImage");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fill");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillPatternX");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillPatternY");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillLinearGradientColorStops");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillRadialGradientStartRadius");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillRadialGradientEndRadius");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillRadialGradientColorStops");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillPatternRepeat");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillEnabled", true);
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "strokeEnabled", true);
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "shadowEnabled", true);
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "dashArrayEnabled", true);
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "fillPriority", "color");
    Kinetic.Node.addGetterSetter(Kinetic.Shape, "strokeScaleEnabled", true);
    Kinetic.Node.addPointGetterSetter(Kinetic.Shape, "fillPatternOffset");
    Kinetic.Node.addPointGetterSetter(Kinetic.Shape, "fillPatternScale");
    Kinetic.Node.addPointGetterSetter(Kinetic.Shape, "fillLinearGradientStartPoint");
    Kinetic.Node.addPointGetterSetter(Kinetic.Shape, "fillLinearGradientEndPoint");
    Kinetic.Node.addPointGetterSetter(Kinetic.Shape, "fillRadialGradientStartPoint");
    Kinetic.Node.addPointGetterSetter(Kinetic.Shape, "fillRadialGradientEndPoint");
    Kinetic.Node.addPointGetterSetter(Kinetic.Shape, "shadowOffset");
    Kinetic.Node.addRotationGetterSetter(Kinetic.Shape, "fillPatternRotation", 0);
})();

(function() {
    var STAGE = "Stage", STRING = "string", PX = "px", MOUSEOUT = "mouseout", MOUSELEAVE = "mouseleave", MOUSEOUT = "mouseout", MOUSEOVER = "mouseover", MOUSEENTER = "mouseenter", MOUSEMOVE = "mousemove", MOUSEDOWN = "mousedown", MOUSEUP = "mouseup", CLICK = "click", DBL_CLICK = "dblclick", TOUCHSTART = "touchstart";
    TOUCHEND = "touchend";
    TAP = "tap", DBL_TAP = "dbltap", TOUCHMOVE = "touchmove", DIV = "div", RELATIVE = "relative", 
    INLINE_BLOCK = "inline-block", KINETICJS_CONTENT = "kineticjs-content", SPACE = " ", 
    CONTAINER = "container", EVENTS = [ MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEOUT, TOUCHSTART, TOUCHMOVE, TOUCHEND ], 
    eventsLength = EVENTS.length;
    function addEvent(ctx, eventName) {
        ctx.content.addEventListener(eventName, function(evt) {
            ctx["_" + eventName](evt);
        }, false);
    }
    Kinetic.Stage = function(config) {
        this._initStage(config);
    };
    Kinetic.Stage.prototype = {
        _initStage: function(config) {
            this.createAttrs();
            Kinetic.Container.call(this, config);
            this.nodeType = STAGE;
            this.dblClickWindow = 400;
            this._id = Kinetic.Global.idCounter++;
            this._buildDOM();
            this._bindContentEvents();
            Kinetic.Global.stages.push(this);
        },
        setContainer: function(container) {
            if (typeof container === STRING) {
                container = document.getElementById(container);
            }
            this.setAttr(CONTAINER, container);
        },
        draw: function() {
            var children = this.getChildren(), len = children.length, n, layer;
            for (n = 0; n < len; n++) {
                layer = children[n];
                if (layer.getClearBeforeDraw()) {
                    layer.getCanvas().clear();
                    layer.getHitCanvas().clear();
                }
            }
            Kinetic.Node.prototype.draw.call(this);
        },
        setHeight: function(height) {
            Kinetic.Node.prototype.setHeight.call(this, height);
            this._resizeDOM();
        },
        setWidth: function(width) {
            Kinetic.Node.prototype.setWidth.call(this, width);
            this._resizeDOM();
        },
        clear: function() {
            var layers = this.children, len = layers.length, n;
            for (n = 0; n < len; n++) {
                layers[n].clear();
            }
        },
        remove: function() {
            var content = this.content;
            Kinetic.Node.prototype.remove.call(this);
            if (content && Kinetic.Type._isInDocument(content)) {
                this.getContainer().removeChild(content);
            }
        },
        getMousePosition: function() {
            return this.mousePos;
        },
        getTouchPosition: function() {
            return this.touchPos;
        },
        getPointerPosition: function() {
            return this.getTouchPosition() || this.getMousePosition();
        },
        getStage: function() {
            return this;
        },
        getContent: function() {
            return this.content;
        },
        toDataURL: function(config) {
            var config = config || {}, mimeType = config.mimeType || null, quality = config.quality || null, x = config.x || 0, y = config.y || 0, canvas = new Kinetic.SceneCanvas({
                width: config.width || this.getWidth(),
                height: config.height || this.getHeight(),
                pixelRatio: 1
            }), context = canvas.getContext(), layers = this.children;
            if (x || y) {
                context.translate(-1 * x, -1 * y);
            }
            function drawLayer(n) {
                var layer = layers[n], layerUrl = layer.toDataURL(), imageObj = new Image();
                imageObj.onload = function() {
                    context.drawImage(imageObj, 0, 0);
                    if (n < layers.length - 1) {
                        drawLayer(n + 1);
                    } else {
                        config.callback(canvas.toDataURL(mimeType, quality));
                    }
                };
                imageObj.src = layerUrl;
            }
            drawLayer(0);
        },
        toImage: function(config) {
            var cb = config.callback;
            config.callback = function(dataUrl) {
                Kinetic.Type._getImage(dataUrl, function(img) {
                    cb(img);
                });
            };
            this.toDataURL(config);
        },
        getIntersection: function() {
            var pos = Kinetic.Type._getXY(Array.prototype.slice.call(arguments)), layers = this.getChildren(), len = layers.length, end = len - 1, n, obj;
            for (n = end; n >= 0; n--) {
                obj = layers[n].getIntersection(pos);
                if (obj) {
                    return obj;
                }
            }
            return null;
        },
        _resizeDOM: function() {
            if (this.content) {
                var width = this.getWidth(), height = this.getHeight(), layers = this.getChildren(), len = layers.length, n;
                this.content.style.width = width + PX;
                this.content.style.height = height + PX;
                this.bufferCanvas.setSize(width, height, 1);
                this.hitCanvas.setSize(width, height);
                for (n = 0; n < len; n++) {
                    layer = layers[n];
                    layer.getCanvas().setSize(width, height);
                    layer.hitCanvas.setSize(width, height);
                    layer.draw();
                }
            }
        },
        add: function(layer) {
            Kinetic.Container.prototype.add.call(this, layer);
            layer.canvas.setSize(this.attrs.width, this.attrs.height);
            layer.hitCanvas.setSize(this.attrs.width, this.attrs.height);
            layer.draw();
            this.content.appendChild(layer.canvas.element);
            return this;
        },
        getParent: function() {
            return null;
        },
        getLayer: function() {
            return null;
        },
        _setPointerPosition: function(evt) {
            if (!evt) {
                evt = window.event;
            }
            this._setMousePosition(evt);
            this._setTouchPosition(evt);
        },
        _bindContentEvents: function() {
            var that = this, n;
            for (n = 0; n < eventsLength; n++) {
                addEvent(this, EVENTS[n]);
            }
        },
        _mouseout: function(evt) {
            this._setPointerPosition(evt);
            var go = Kinetic.Global, targetShape = this.targetShape;
            if (targetShape && !go.isDragging()) {
                targetShape._handleEvent(MOUSEOUT, evt);
                targetShape._handleEvent(MOUSELEAVE, evt);
                this.targetShape = null;
            }
            this.mousePos = undefined;
        },
        _mousemove: function(evt) {
            this._setPointerPosition(evt);
            var go = Kinetic.Global, dd = Kinetic.DD, obj = this.getIntersection(this.getPointerPosition()), shape;
            if (obj) {
                shape = obj.shape;
                if (shape) {
                    if (!go.isDragging() && obj.pixel[3] === 255 && (!this.targetShape || this.targetShape._id !== shape._id)) {
                        if (this.targetShape) {
                            this.targetShape._handleEvent(MOUSEOUT, evt, shape);
                            this.targetShape._handleEvent(MOUSELEAVE, evt, shape);
                        }
                        shape._handleEvent(MOUSEOVER, evt, this.targetShape);
                        shape._handleEvent(MOUSEENTER, evt, this.targetShape);
                        this.targetShape = shape;
                    } else {
                        shape._handleEvent(MOUSEMOVE, evt);
                    }
                }
            } else if (this.targetShape && !go.isDragging()) {
                this.targetShape._handleEvent(MOUSEOUT, evt);
                this.targetShape._handleEvent(MOUSELEAVE, evt);
                this.targetShape = null;
            }
            if (dd) {
                dd._drag(evt);
            }
        },
        _mousedown: function(evt) {
            this._setPointerPosition(evt);
            var go = Kinetic.Global, obj = this.getIntersection(this.getPointerPosition()), shape;
            if (obj && obj.shape) {
                shape = obj.shape;
                this.clickStart = true;
                this.clickStartShape = shape;
                shape._handleEvent(MOUSEDOWN, evt);
            }
            if (this.isDraggable() && !go.isDragReady()) {
                this.startDrag(evt);
            }
        },
        _mouseup: function(evt) {
            this._setPointerPosition(evt);
            var that = this, go = Kinetic.Global, obj = this.getIntersection(this.getPointerPosition()), shape;
            if (obj && obj.shape) {
                shape = obj.shape;
                shape._handleEvent(MOUSEUP, evt);
                if (this.clickStart) {
                    if (!go.isDragging() && shape._id === this.clickStartShape._id) {
                        shape._handleEvent(CLICK, evt);
                        if (this.inDoubleClickWindow) {
                            shape._handleEvent(DBL_CLICK, evt);
                        }
                        this.inDoubleClickWindow = true;
                        setTimeout(function() {
                            that.inDoubleClickWindow = false;
                        }, this.dblClickWindow);
                    }
                }
            }
            this.clickStart = false;
        },
        _touchstart: function(evt) {
            this._setPointerPosition(evt);
            var go = Kinetic.Global, obj = this.getIntersection(this.getPointerPosition()), shape;
            evt.preventDefault();
            if (obj && obj.shape) {
                shape = obj.shape;
                this.tapStart = true;
                this.tapStartShape = shape;
                shape._handleEvent(TOUCHSTART, evt);
            }
            if (this.isDraggable() && !go.isDragReady()) {
                this.startDrag(evt);
            }
        },
        _touchend: function(evt) {
            this._setPointerPosition(evt);
            var that = this, go = Kinetic.Global, obj = this.getIntersection(this.getPointerPosition()), shape;
            if (obj && obj.shape) {
                shape = obj.shape;
                shape._handleEvent(TOUCHEND, evt);
                if (this.tapStart) {
                    if (!go.isDragging() && shape._id === this.tapStartShape._id) {
                        shape._handleEvent(TAP, evt);
                        if (this.inDoubleClickWindow) {
                            shape._handleEvent(DBL_TAP, evt);
                        }
                        this.inDoubleClickWindow = true;
                        setTimeout(function() {
                            that.inDoubleClickWindow = false;
                        }, this.dblClickWindow);
                    }
                }
            }
            this.tapStart = false;
        },
        _touchmove: function(evt) {
            this._setPointerPosition(evt);
            var dd = Kinetic.DD, obj = this.getIntersection(this.getPointerPosition()), shape;
            evt.preventDefault();
            if (obj && obj.shape) {
                shape = obj.shape;
                shape._handleEvent(TOUCHMOVE, evt);
            }
            if (dd) {
                dd._drag(evt);
            }
        },
        _setMousePosition: function(evt) {
            var mouseX = evt.clientX - this._getContentPosition().left, mouseY = evt.clientY - this._getContentPosition().top;
            this.mousePos = {
                x: mouseX,
                y: mouseY
            };
        },
        _setTouchPosition: function(evt) {
            var touch, touchX, touchY;
            if (evt.touches !== undefined && evt.touches.length === 1) {
                touch = evt.touches[0];
                touchX = touch.clientX - this._getContentPosition().left;
                touchY = touch.clientY - this._getContentPosition().top;
                this.touchPos = {
                    x: touchX,
                    y: touchY
                };
            }
        },
        _getContentPosition: function() {
            var rect = this.content.getBoundingClientRect();
            return {
                top: rect.top,
                left: rect.left
            };
        },
        _buildDOM: function() {
            this.content = document.createElement(DIV);
            this.content.style.position = RELATIVE;
            this.content.style.display = INLINE_BLOCK;
            this.content.className = KINETICJS_CONTENT;
            this.attrs.container.appendChild(this.content);
            this.bufferCanvas = new Kinetic.SceneCanvas();
            this.hitCanvas = new Kinetic.HitCanvas();
            this._resizeDOM();
        },
        _onContent: function(typesStr, handler) {
            var types = typesStr.split(SPACE), len = types.length, n, baseEvent;
            for (n = 0; n < len; n++) {
                baseEvent = types[n];
                this.content.addEventListener(baseEvent, handler, false);
            }
        }
    };
    Kinetic.Global.extend(Kinetic.Stage, Kinetic.Container);
    Kinetic.Node.addGetter(Kinetic.Stage, "container");
})();

(function() {
    Kinetic.Layer = function(config) {
        this._initLayer(config);
    };
    Kinetic.Layer.prototype = {
        _initLayer: function(config) {
            this.nodeType = "Layer";
            this.createAttrs();
            Kinetic.Container.call(this, config);
            this.canvas = new Kinetic.SceneCanvas();
            this.canvas.getElement().style.position = "absolute";
            this.hitCanvas = new Kinetic.HitCanvas();
        },
        getIntersection: function() {
            var pos = Kinetic.Type._getXY(Array.prototype.slice.call(arguments)), p, colorKey, shape;
            if (this.isVisible() && this.isListening()) {
                p = this.hitCanvas.context.getImageData(pos.x | 0, pos.y | 0, 1, 1).data;
                if (p[3] === 255) {
                    colorKey = Kinetic.Type._rgbToHex(p[0], p[1], p[2]);
                    shape = Kinetic.Global.shapes[colorKey];
                    return {
                        shape: shape,
                        pixel: p
                    };
                } else if (p[0] > 0 || p[1] > 0 || p[2] > 0 || p[3] > 0) {
                    return {
                        pixel: p
                    };
                }
            }
            return null;
        },
        drawScene: function(canvas) {
            var canvas = canvas || this.getCanvas();
            if (this.getClearBeforeDraw()) {
                canvas.clear();
            }
            Kinetic.Container.prototype.drawScene.call(this, canvas);
        },
        drawHit: function() {
            var layer = this.getLayer();
            if (layer && layer.getClearBeforeDraw()) {
                layer.getHitCanvas().clear();
            }
            Kinetic.Container.prototype.drawHit.call(this);
        },
        getCanvas: function() {
            return this.canvas;
        },
        getHitCanvas: function() {
            return this.hitCanvas;
        },
        getContext: function() {
            return this.getCanvas().getContext();
        },
        clear: function() {
            this.getCanvas().clear();
        },
        setVisible: function(visible) {
            Kinetic.Node.prototype.setVisible.call(this, visible);
            if (visible) {
                this.getCanvas().element.style.display = "block";
                this.hitCanvas.element.style.display = "block";
            } else {
                this.getCanvas().element.style.display = "none";
                this.hitCanvas.element.style.display = "none";
            }
        },
        setZIndex: function(index) {
            Kinetic.Node.prototype.setZIndex.call(this, index);
            var stage = this.getStage();
            if (stage) {
                stage.content.removeChild(this.getCanvas().element);
                if (index < stage.getChildren().length - 1) {
                    stage.content.insertBefore(this.getCanvas().element, stage.getChildren()[index + 1].getCanvas().element);
                } else {
                    stage.content.appendChild(this.getCanvas().element);
                }
            }
        },
        moveToTop: function() {
            Kinetic.Node.prototype.moveToTop.call(this);
            var stage = this.getStage();
            if (stage) {
                stage.content.removeChild(this.getCanvas().element);
                stage.content.appendChild(this.getCanvas().element);
            }
        },
        moveUp: function() {
            if (Kinetic.Node.prototype.moveUp.call(this)) {
                var stage = this.getStage();
                if (stage) {
                    stage.content.removeChild(this.getCanvas().element);
                    if (this.index < stage.getChildren().length - 1) {
                        stage.content.insertBefore(this.getCanvas().element, stage.getChildren()[this.index + 1].getCanvas().element);
                    } else {
                        stage.content.appendChild(this.getCanvas().element);
                    }
                }
            }
        },
        moveDown: function() {
            if (Kinetic.Node.prototype.moveDown.call(this)) {
                var stage = this.getStage();
                if (stage) {
                    var children = stage.getChildren();
                    stage.content.removeChild(this.getCanvas().element);
                    stage.content.insertBefore(this.getCanvas().element, children[this.index + 1].getCanvas().element);
                }
            }
        },
        moveToBottom: function() {
            if (Kinetic.Node.prototype.moveToBottom.call(this)) {
                var stage = this.getStage();
                if (stage) {
                    var children = stage.getChildren();
                    stage.content.removeChild(this.getCanvas().element);
                    stage.content.insertBefore(this.getCanvas().element, children[1].getCanvas().element);
                }
            }
        },
        getLayer: function() {
            return this;
        },
        remove: function() {
            var stage = this.getStage(), canvas = this.getCanvas(), element = canvas.element;
            Kinetic.Node.prototype.remove.call(this);
            if (stage && canvas && Kinetic.Type._isInDocument(element)) {
                stage.content.removeChild(element);
            }
        }
    };
    Kinetic.Global.extend(Kinetic.Layer, Kinetic.Container);
    Kinetic.Node.addGetterSetter(Kinetic.Layer, "clearBeforeDraw", true);
})();

(function() {
    Kinetic.Group = function(config) {
        this._initGroup(config);
    };
    Kinetic.Group.prototype = {
        _initGroup: function(config) {
            this.nodeType = "Group";
            this.createAttrs();
            Kinetic.Container.call(this, config);
        }
    };
    Kinetic.Global.extend(Kinetic.Group, Kinetic.Container);
})();

(function() {
    Kinetic.Rect = function(config) {
        this._initRect(config);
    };
    Kinetic.Rect.prototype = {
        _initRect: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "Rect";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var context = canvas.getContext(), cornerRadius = this.getCornerRadius(), width = this.getWidth(), height = this.getHeight();
            context.beginPath();
            if (!cornerRadius) {
                context.rect(0, 0, width, height);
            } else {
                context.moveTo(cornerRadius, 0);
                context.lineTo(width - cornerRadius, 0);
                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
                context.lineTo(width, height - cornerRadius);
                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
                context.lineTo(cornerRadius, height);
                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
                context.lineTo(0, cornerRadius);
                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
            }
            context.closePath();
            canvas.fillStroke(this);
        }
    };
    Kinetic.Global.extend(Kinetic.Rect, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.Rect, "cornerRadius", 0);
})();

(function() {
    Kinetic.Circle = function(config) {
        this._initCircle(config);
    };
    Kinetic.Circle.prototype = {
        _initCircle: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "Circle";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var context = canvas.getContext();
            context.beginPath();
            context.arc(0, 0, this.getRadius(), 0, Math.PI * 2, true);
            context.closePath();
            canvas.fillStroke(this);
        },
        getWidth: function() {
            return this.getRadius() * 2;
        },
        getHeight: function() {
            return this.getRadius() * 2;
        },
        setWidth: function(width) {
            Kinetic.Node.prototype.setWidth.call(this, width);
            this.setRadius(width / 2);
        },
        setHeight: function(height) {
            Kinetic.Node.prototype.setHeight.call(this, height);
            this.setRadius(height / 2);
        }
    };
    Kinetic.Global.extend(Kinetic.Circle, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.Circle, "radius", 0);
})();

(function() {
    Kinetic.Wedge = function(config) {
        this._initWedge(config);
    };
    Kinetic.Wedge.prototype = {
        _initWedge: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "Wedge";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var context = canvas.getContext();
            context.beginPath();
            context.arc(0, 0, this.getRadius(), 0, this.getAngle(), this.getClockwise());
            context.lineTo(0, 0);
            context.closePath();
            canvas.fillStroke(this);
        },
        setAngleDeg: function(deg) {
            this.setAngle(Kinetic.Type._degToRad(deg));
        },
        getAngleDeg: function() {
            return Kinetic.Type._radToDeg(this.getAngle());
        }
    };
    Kinetic.Global.extend(Kinetic.Wedge, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.Wedge, "radius", 0);
    Kinetic.Node.addGetterSetter(Kinetic.Wedge, "angle", 0);
    Kinetic.Node.addGetterSetter(Kinetic.Wedge, "clockwise", false);
})();

(function() {
    Kinetic.Ellipse = function(config) {
        this._initEllipse(config);
    };
    Kinetic.Ellipse.prototype = {
        _initEllipse: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "Ellipse";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var context = canvas.getContext(), r = this.getRadius();
            context.beginPath();
            context.save();
            if (r.x !== r.y) {
                context.scale(1, r.y / r.x);
            }
            context.arc(0, 0, r.x, 0, Math.PI * 2, true);
            context.restore();
            context.closePath();
            canvas.fillStroke(this);
        },
        getWidth: function() {
            return this.getRadius().x * 2;
        },
        getHeight: function() {
            return this.getRadius().y * 2;
        },
        setWidth: function(width) {
            Kinetic.Node.prototype.setWidth.call(this, width);
            this.setRadius({
                x: width / 2
            });
        },
        setHeight: function(height) {
            Kinetic.Node.prototype.setHeight.call(this, height);
            this.setRadius({
                y: height / 2
            });
        }
    };
    Kinetic.Global.extend(Kinetic.Ellipse, Kinetic.Shape);
    Kinetic.Node.addPointGetterSetter(Kinetic.Ellipse, "radius", {
        x: 0,
        y: 0
    });
})();

(function() {
    var IMAGE = "Image", CROP = "crop";
    Kinetic.Image = function(config) {
        this._initImage(config);
    };
    Kinetic.Image.prototype = {
        _initImage: function(config) {
            var that = this;
            Kinetic.Shape.call(this, config);
            this.shapeType = IMAGE;
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var width = this.getWidth(), height = this.getHeight(), params, that = this, context = canvas.getContext(), image = this.getImage(), crop = this.getCrop(), cropX, cropY, cropWidth, cropHeight;
            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            canvas.fillStroke(this);
            if (image) {
                if (crop) {
                    cropX = crop.x || 0;
                    cropY = crop.y || 0;
                    cropWidth = crop.width || 0;
                    cropHeight = crop.height || 0;
                    params = [ image, cropX, cropY, cropWidth, cropHeight, 0, 0, width, height ];
                } else {
                    params = [ image, 0, 0, width, height ];
                }
                if (this.hasShadow()) {
                    canvas.applyShadow(this, function() {
                        that._drawImage(context, params);
                    });
                } else {
                    this._drawImage(context, params);
                }
            }
        },
        drawHitFunc: function(canvas) {
            var width = this.getWidth(), height = this.getHeight(), imageHitRegion = this.imageHitRegion, context = canvas.getContext();
            if (imageHitRegion) {
                context.drawImage(imageHitRegion, 0, 0, width, height);
                context.beginPath();
                context.rect(0, 0, width, height);
                context.closePath();
                canvas.stroke(this);
            } else {
                context.beginPath();
                context.rect(0, 0, width, height);
                context.closePath();
                canvas.fillStroke(this);
            }
        },
        applyFilter: function(filter, config, callback) {
            var image = this.getImage(), canvas = new Kinetic.Canvas({
                width: image.width,
                height: image.height
            }), context = canvas.getContext(), that = this;
            context.drawImage(image, 0, 0);
            try {
                var imageData = context.getImageData(0, 0, canvas.getWidth(), canvas.getHeight());
                filter(imageData, config);
                Kinetic.Type._getImage(imageData, function(imageObj) {
                    that.setImage(imageObj);
                    if (callback) {
                        callback();
                    }
                });
            } catch (e) {
                Kinetic.Global.warn("Unable to apply filter. " + e.message);
            }
        },
        setCrop: function() {
            var config = [].slice.call(arguments), pos = Kinetic.Type._getXY(config), size = Kinetic.Type._getSize(config), both = Kinetic.Type._merge(pos, size);
            this.setAttr(CROP, Kinetic.Type._merge(both, this.getCrop()));
        },
        createImageHitRegion: function(callback) {
            var that = this, width = this.getWidth(), height = this.getHeight(), canvas = new Kinetic.Canvas({
                width: width,
                height: height
            }), context = canvas.getContext(), image = this.getImage(), imageData, data, rgbColorKey, i, n;
            context.drawImage(image, 0, 0);
            try {
                imageData = context.getImageData(0, 0, width, height);
                data = imageData.data;
                rgbColorKey = Kinetic.Type._hexToRgb(this.colorKey);
                for (i = 0, n = data.length; i < n; i += 4) {
                    if (data[i + 3] > 0) {
                        data[i] = rgbColorKey.r;
                        data[i + 1] = rgbColorKey.g;
                        data[i + 2] = rgbColorKey.b;
                    }
                }
                Kinetic.Type._getImage(imageData, function(imageObj) {
                    that.imageHitRegion = imageObj;
                    if (callback) {
                        callback();
                    }
                });
            } catch (e) {
                Kinetic.Global.warn("Unable to create image hit region. " + e.message);
            }
        },
        clearImageHitRegion: function() {
            delete this.imageHitRegion;
        },
        getWidth: function() {
            var image = this.getImage();
            return this.attrs.width || (image ? image.width : 0);
        },
        getHeight: function() {
            var image = this.getImage();
            return this.attrs.height || (image ? image.height : 0);
        },
        _drawImage: function(context, a) {
            if (a.length === 5) {
                context.drawImage(a[0], a[1], a[2], a[3], a[4]);
            } else if (a.length === 9) {
                context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
            }
        }
    };
    Kinetic.Global.extend(Kinetic.Image, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.Image, "image");
    Kinetic.Node.addGetter(Kinetic.Image, "crop");
})();

(function() {
    Kinetic.Polygon = function(config) {
        this._initPolygon(config);
    };
    Kinetic.Polygon.prototype = {
        _initPolygon: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "Polygon";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var context = canvas.getContext(), points = this.getPoints(), length = points.length;
            context.beginPath();
            context.moveTo(points[0].x, points[0].y);
            for (var n = 1; n < length; n++) {
                context.lineTo(points[n].x, points[n].y);
            }
            context.closePath();
            canvas.fillStroke(this);
        },
        setPoints: function(val) {
            this.setAttr("points", Kinetic.Type._getPoints(val));
        },
        getPoints: function() {
            return this.attrs.points || [];
        }
    };
    Kinetic.Global.extend(Kinetic.Polygon, Kinetic.Shape);
})();

(function() {
    var AUTO = "auto", CALIBRI = "Calibri", CANVAS = "canvas", CENTER = "center", CHANGE_KINETIC = "Change.kinetic", CONTEXT_2D = "2d", DASH = "-", EMPTY_STRING = "", LEFT = "left", NEW_LINE = "\n", TEXT = "text", TEXT_UPPER = "Text", TOP = "top", MIDDLE = "middle", NORMAL = "normal", PX_SPACE = "px ", SPACE = " ", RIGHT = "right", WORD = "word", CHAR = "char", NONE = "none", ATTR_CHANGE_LIST = [ "fontFamily", "fontSize", "fontStyle", "padding", "align", "lineHeight", "text", "width", "height", "wrap" ], attrChangeListLen = ATTR_CHANGE_LIST.length, dummyContext = document.createElement(CANVAS).getContext(CONTEXT_2D);
    Kinetic.Text = function(config) {
        this._initText(config);
    };
    function _fillFunc(context) {
        context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
        context.strokeText(this.partialText, 0, 0);
    }
    Kinetic.Text.prototype = {
        _initText: function(config) {
            var that = this;
            this.createAttrs();
            this.attrs.width = AUTO;
            this.attrs.height = AUTO;
            Kinetic.Shape.call(this, config);
            this.shapeType = TEXT;
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this.shapeType = TEXT_UPPER;
            this._setDrawFuncs();
            for (var n = 0; n < attrChangeListLen; n++) {
                this.on(ATTR_CHANGE_LIST[n] + CHANGE_KINETIC, that._setTextData);
            }
            this._setTextData();
        },
        drawFunc: function(canvas) {
            var context = canvas.getContext(), p = this.getPadding(), fontStyle = this.getFontStyle(), fontSize = this.getFontSize(), fontFamily = this.getFontFamily(), textHeight = this.getTextHeight(), lineHeightPx = this.getLineHeight() * textHeight, textArr = this.textArr, textArrLen = textArr.length, totalWidth = this.getWidth();
            context.font = this._getContextFont();
            context.textBaseline = MIDDLE;
            context.textAlign = LEFT;
            context.save();
            context.translate(p, 0);
            context.translate(0, p + textHeight / 2);
            for (var n = 0; n < textArrLen; n++) {
                var obj = textArr[n], text = obj.text, width = obj.width;
                context.save();
                if (this.getAlign() === RIGHT) {
                    context.translate(totalWidth - width - p * 2, 0);
                } else if (this.getAlign() === CENTER) {
                    context.translate((totalWidth - width - p * 2) / 2, 0);
                }
                this.partialText = text;
                canvas.fillStroke(this);
                context.restore();
                context.translate(0, lineHeightPx);
            }
            context.restore();
        },
        drawHitFunc: function(canvas) {
            var context = canvas.getContext(), width = this.getWidth(), height = this.getHeight();
            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            canvas.fillStroke(this);
        },
        setText: function(text) {
            var str = Kinetic.Type._isString(text) ? text : text.toString();
            this.setAttr(TEXT, str);
        },
        getWidth: function() {
            return this.attrs.width === AUTO ? this.getTextWidth() + this.getPadding() * 2 : this.attrs.width;
        },
        getHeight: function() {
            return this.attrs.height === AUTO ? this.getTextHeight() * this.textArr.length * this.getLineHeight() + this.getPadding() * 2 : this.attrs.height;
        },
        getTextWidth: function() {
            return this.textWidth;
        },
        getTextHeight: function() {
            return this.textHeight;
        },
        _getTextSize: function(text) {
            var context = dummyContext, fontSize = this.getFontSize(), metrics;
            context.save();
            context.font = this._getContextFont();
            metrics = context.measureText(text);
            context.restore();
            return {
                width: metrics.width,
                height: parseInt(fontSize, 10)
            };
        },
        _getContextFont: function() {
            return this.getFontStyle() + SPACE + this.getFontSize() + PX_SPACE + this.getFontFamily();
        },
        _addTextLine: function(line, width, height) {
            return this.textArr.push({
                text: line,
                width: width
            });
        },
        _getTextWidth: function(text) {
            return dummyContext.measureText(text).width;
        },
        _setTextData: function() {
            var lines = this.getText().split("\n"), fontSize = +this.getFontSize(), textWidth = 0, lineHeightPx = this.getLineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO, fixedHeight = height !== AUTO, padding = this.getPadding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.getWrap(), shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap;
            this.textArr = [];
            dummyContext.save();
            dummyContext.font = this.getFontStyle() + SPACE + fontSize + PX_SPACE + this.getFontFamily();
            for (var i = 0, max = lines.length; i < max; ++i) {
                var line = lines[i], lineWidth = this._getTextWidth(line);
                if (fixedWidth && lineWidth > maxWidth) {
                    while (line.length > 0) {
                        var low = 0, high = line.length, match = "", matchWidth = 0;
                        while (low < high) {
                            var mid = low + high >>> 1, substr = line.slice(0, mid + 1), substrWidth = this._getTextWidth(substr);
                            if (substrWidth <= maxWidth) {
                                low = mid + 1;
                                match = substr;
                                matchWidth = substrWidth;
                            } else {
                                high = mid;
                            }
                        }
                        if (match) {
                            if (wrapAtWord) {
                                var wrapIndex = Math.max(match.lastIndexOf(SPACE), match.lastIndexOf(DASH)) + 1;
                                if (wrapIndex > 0) {
                                    low = wrapIndex;
                                    match = match.slice(0, low);
                                    matchWidth = this._getTextWidth(match);
                                }
                            }
                            this._addTextLine(match, matchWidth);
                            currentHeightPx += lineHeightPx;
                            if (!shouldWrap || fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
                                break;
                            }
                            line = line.slice(low);
                            if (line.length > 0) {
                                lineWidth = this._getTextWidth(line);
                                if (lineWidth <= maxWidth) {
                                    this._addTextLine(line, lineWidth);
                                    currentHeightPx += lineHeightPx;
                                    break;
                                }
                            }
                        } else {
                            break;
                        }
                    }
                } else {
                    this._addTextLine(line, lineWidth);
                    currentHeightPx += lineHeightPx;
                    textWidth = Math.max(textWidth, lineWidth);
                }
                if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
                    break;
                }
            }
            dummyContext.restore();
            this.textHeight = fontSize;
            this.textWidth = textWidth;
        }
    };
    Kinetic.Global.extend(Kinetic.Text, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.Text, "fontFamily", CALIBRI);
    Kinetic.Node.addGetterSetter(Kinetic.Text, "fontSize", 12);
    Kinetic.Node.addGetterSetter(Kinetic.Text, "fontStyle", NORMAL);
    Kinetic.Node.addGetterSetter(Kinetic.Text, "padding", 0);
    Kinetic.Node.addGetterSetter(Kinetic.Text, "align", LEFT);
    Kinetic.Node.addGetterSetter(Kinetic.Text, "lineHeight", 1);
    Kinetic.Node.addGetterSetter(Kinetic.Text, "wrap", WORD);
    Kinetic.Node.addGetter(Kinetic.Text, TEXT, EMPTY_STRING);
    Kinetic.Node.addSetter(Kinetic.Text, "width");
    Kinetic.Node.addSetter(Kinetic.Text, "height");
})();

(function() {
    Kinetic.Line = function(config) {
        this._initLine(config);
    };
    Kinetic.Line.prototype = {
        _initLine: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "Line";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var points = this.getPoints(), length = points.length, context = canvas.getContext();
            context.beginPath();
            context.moveTo(points[0].x, points[0].y);
            for (var n = 1; n < length; n++) {
                var point = points[n];
                context.lineTo(point.x, point.y);
            }
            canvas.stroke(this);
        },
        setPoints: function(val) {
            this.setAttr("points", Kinetic.Type._getPoints(val));
        },
        getPoints: function() {
            return this.attrs.points || [];
        }
    };
    Kinetic.Global.extend(Kinetic.Line, Kinetic.Shape);
})();

(function() {
    Kinetic.Spline = function(config) {
        this._initSpline(config);
    };
    Kinetic.Spline._getControlPoints = function(p0, p1, p2, t) {
        var x0 = p0.x;
        var y0 = p0.y;
        var x1 = p1.x;
        var y1 = p1.y;
        var x2 = p2.x;
        var y2 = p2.y;
        var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
        var d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        var fa = t * d01 / (d01 + d12);
        var fb = t * d12 / (d01 + d12);
        var p1x = x1 - fa * (x2 - x0);
        var p1y = y1 - fa * (y2 - y0);
        var p2x = x1 + fb * (x2 - x0);
        var p2y = y1 + fb * (y2 - y0);
        return [ {
            x: p1x,
            y: p1y
        }, {
            x: p2x,
            y: p2y
        } ];
    };
    Kinetic.Spline.prototype = {
        _initSpline: function(config) {
            this.createAttrs();
            Kinetic.Line.call(this, config);
            this.shapeType = "Spline";
        },
        drawFunc: function(canvas) {
            var points = this.getPoints(), length = points.length, context = canvas.getContext(), tension = this.getTension();
            context.beginPath();
            context.moveTo(points[0].x, points[0].y);
            if (tension !== 0 && length > 2) {
                var ap = this.allPoints, len = ap.length;
                context.quadraticCurveTo(ap[0].x, ap[0].y, ap[1].x, ap[1].y);
                var n = 2;
                while (n < len - 1) {
                    context.bezierCurveTo(ap[n].x, ap[n++].y, ap[n].x, ap[n++].y, ap[n].x, ap[n++].y);
                }
                context.quadraticCurveTo(ap[len - 1].x, ap[len - 1].y, points[length - 1].x, points[length - 1].y);
            } else {
                for (var n = 1; n < length; n++) {
                    var point = points[n];
                    context.lineTo(point.x, point.y);
                }
            }
            canvas.stroke(this);
        },
        setPoints: function(val) {
            Kinetic.Line.prototype.setPoints.call(this, val);
            this._setAllPoints();
        },
        setTension: function(tension) {
            this.setAttr("tension", tension);
            this._setAllPoints();
        },
        _setAllPoints: function() {
            var points = this.getPoints(), length = points.length, tension = this.getTension(), allPoints = [];
            for (var n = 1; n < length - 1; n++) {
                var cp = Kinetic.Spline._getControlPoints(points[n - 1], points[n], points[n + 1], tension);
                allPoints.push(cp[0]);
                allPoints.push(points[n]);
                allPoints.push(cp[1]);
            }
            this.allPoints = allPoints;
        }
    };
    Kinetic.Global.extend(Kinetic.Spline, Kinetic.Line);
    Kinetic.Node.addGetter(Kinetic.Spline, "tension", 1);
})();

(function() {
    Kinetic.Blob = function(config) {
        this._initBlob(config);
    };
    Kinetic.Blob.prototype = {
        _initBlob: function(config) {
            Kinetic.Spline.call(this, config);
            this.shapeType = "Blob";
        },
        drawFunc: function(canvas) {
            var points = this.getPoints(), length = points.length, context = canvas.getContext(), tension = this.getTension();
            context.beginPath();
            context.moveTo(points[0].x, points[0].y);
            if (tension !== 0 && length > 2) {
                var ap = this.allPoints, len = ap.length;
                var n = 0;
                while (n < len - 1) {
                    context.bezierCurveTo(ap[n].x, ap[n++].y, ap[n].x, ap[n++].y, ap[n].x, ap[n++].y);
                }
            } else {
                for (var n = 1; n < length; n++) {
                    var point = points[n];
                    context.lineTo(point.x, point.y);
                }
            }
            context.closePath();
            canvas.fillStroke(this);
        },
        _setAllPoints: function() {
            var points = this.getPoints(), length = points.length, tension = this.getTension(), firstControlPoints = Kinetic.Spline._getControlPoints(points[length - 1], points[0], points[1], tension), lastControlPoints = Kinetic.Spline._getControlPoints(points[length - 2], points[length - 1], points[0], tension);
            Kinetic.Spline.prototype._setAllPoints.call(this);
            this.allPoints.unshift(firstControlPoints[1]);
            this.allPoints.push(lastControlPoints[0]);
            this.allPoints.push(points[length - 1]);
            this.allPoints.push(lastControlPoints[1]);
            this.allPoints.push(firstControlPoints[0]);
            this.allPoints.push(points[0]);
        }
    };
    Kinetic.Global.extend(Kinetic.Blob, Kinetic.Spline);
})();

(function() {
    Kinetic.Sprite = function(config) {
        this._initSprite(config);
    };
    Kinetic.Sprite.prototype = {
        _initSprite: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "Sprite";
            this._setDrawFuncs();
            this.anim = new Kinetic.Animation();
            var that = this;
            this.on("animationChange", function() {
                that.setIndex(0);
            });
        },
        drawFunc: function(canvas) {
            var anim = this.getAnimation(), index = this.getIndex(), f = this.getAnimations()[anim][index], context = canvas.getContext(), image = this.getImage();
            if (image) {
                context.drawImage(image, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
            }
        },
        drawHitFunc: function(canvas) {
            var anim = this.getAnimation(), index = this.getIndex(), f = this.getAnimations()[anim][index], context = canvas.getContext();
            context.beginPath();
            context.rect(0, 0, f.width, f.height);
            context.closePath();
            canvas.fill(this);
        },
        start: function() {
            var that = this;
            var layer = this.getLayer();
            this.anim.node = layer;
            this.interval = setInterval(function() {
                var index = that.getIndex();
                that._updateIndex();
                if (that.afterFrameFunc && index === that.afterFrameIndex) {
                    that.afterFrameFunc();
                    delete that.afterFrameFunc;
                    delete that.afterFrameIndex;
                }
            }, 1e3 / this.getFrameRate());
            this.anim.start();
        },
        stop: function() {
            this.anim.stop();
            clearInterval(this.interval);
        },
        afterFrame: function(index, func) {
            this.afterFrameIndex = index;
            this.afterFrameFunc = func;
        },
        _updateIndex: function() {
            var index = this.getIndex(), animation = this.getAnimation(), animations = this.getAnimations(), anim = animations[animation], len = anim.length;
            if (index < len - 1) {
                this.setIndex(index + 1);
            } else {
                this.setIndex(0);
            }
        }
    };
    Kinetic.Global.extend(Kinetic.Sprite, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.Sprite, "animation");
    Kinetic.Node.addGetterSetter(Kinetic.Sprite, "animations");
    Kinetic.Node.addGetterSetter(Kinetic.Sprite, "image");
    Kinetic.Node.addGetterSetter(Kinetic.Sprite, "index", 0);
    Kinetic.Node.addGetterSetter(Kinetic.Sprite, "frameRate", 17);
})();

(function() {
    Kinetic.Path = function(config) {
        this._initPath(config);
    };
    Kinetic.Path.prototype = {
        _initPath: function(config) {
            this.dataArray = [];
            var that = this;
            Kinetic.Shape.call(this, config);
            this.shapeType = "Path";
            this._setDrawFuncs();
            this.dataArray = Kinetic.Path.parsePathData(this.getData());
            this.on("dataChange", function() {
                that.dataArray = Kinetic.Path.parsePathData(this.getData());
            });
        },
        drawFunc: function(canvas) {
            var ca = this.dataArray, context = canvas.getContext();
            context.beginPath();
            for (var n = 0; n < ca.length; n++) {
                var c = ca[n].command;
                var p = ca[n].points;
                switch (c) {
                  case "L":
                    context.lineTo(p[0], p[1]);
                    break;

                  case "M":
                    context.moveTo(p[0], p[1]);
                    break;

                  case "C":
                    context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                    break;

                  case "Q":
                    context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                    break;

                  case "A":
                    var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];
                    var r = rx > ry ? rx : ry;
                    var scaleX = rx > ry ? 1 : rx / ry;
                    var scaleY = rx > ry ? ry / rx : 1;
                    context.translate(cx, cy);
                    context.rotate(psi);
                    context.scale(scaleX, scaleY);
                    context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                    context.scale(1 / scaleX, 1 / scaleY);
                    context.rotate(-psi);
                    context.translate(-cx, -cy);
                    break;

                  case "z":
                    context.closePath();
                    break;
                }
            }
            canvas.fillStroke(this);
        }
    };
    Kinetic.Global.extend(Kinetic.Path, Kinetic.Shape);
    Kinetic.Path.getLineLength = function(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    };
    Kinetic.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
        if (fromX === undefined) {
            fromX = P1x;
        }
        if (fromY === undefined) {
            fromY = P1y;
        }
        var m = (P2y - P1y) / (P2x - P1x + 1e-8);
        var run = Math.sqrt(dist * dist / (1 + m * m));
        if (P2x < P1x) run *= -1;
        var rise = m * run;
        var pt;
        if ((fromY - P1y) / (fromX - P1x + 1e-8) === m) {
            pt = {
                x: fromX + run,
                y: fromY + rise
            };
        } else {
            var ix, iy;
            var len = this.getLineLength(P1x, P1y, P2x, P2y);
            if (len < 1e-8) {
                return undefined;
            }
            var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
            u = u / (len * len);
            ix = P1x + u * (P2x - P1x);
            iy = P1y + u * (P2y - P1y);
            var pRise = this.getLineLength(fromX, fromY, ix, iy);
            var pRun = Math.sqrt(dist * dist - pRise * pRise);
            run = Math.sqrt(pRun * pRun / (1 + m * m));
            if (P2x < P1x) run *= -1;
            rise = m * run;
            pt = {
                x: ix + run,
                y: iy + rise
            };
        }
        return pt;
    };
    Kinetic.Path.getPointOnCubicBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
            return t * t * t;
        }
        function CB2(t) {
            return 3 * t * t * (1 - t);
        }
        function CB3(t) {
            return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
            return (1 - t) * (1 - t) * (1 - t);
        }
        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
        return {
            x: x,
            y: y
        };
    };
    Kinetic.Path.getPointOnQuadraticBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
            return t * t;
        }
        function QB2(t) {
            return 2 * t * (1 - t);
        }
        function QB3(t) {
            return (1 - t) * (1 - t);
        }
        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
        return {
            x: x,
            y: y
        };
    };
    Kinetic.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
        var pt = {
            x: rx * Math.cos(theta),
            y: ry * Math.sin(theta)
        };
        return {
            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
            y: cy + (pt.x * sinPsi + pt.y * cosPsi)
        };
    };
    Kinetic.Path.parsePathData = function(data) {
        if (!data) {
            return [];
        }
        var cs = data;
        var cc = [ "m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A" ];
        cs = cs.replace(new RegExp(" ", "g"), ",");
        for (var n = 0; n < cc.length; n++) {
            cs = cs.replace(new RegExp(cc[n], "g"), "|" + cc[n]);
        }
        var arr = cs.split("|");
        var ca = [];
        var cpx = 0;
        var cpy = 0;
        for (var n = 1; n < arr.length; n++) {
            var str = arr[n];
            var c = str.charAt(0);
            str = str.slice(1);
            str = str.replace(new RegExp(",-", "g"), "-");
            str = str.replace(new RegExp("-", "g"), ",-");
            str = str.replace(new RegExp("e,-", "g"), "e-");
            var p = str.split(",");
            if (p.length > 0 && p[0] === "") {
                p.shift();
            }
            for (var i = 0; i < p.length; i++) {
                p[i] = parseFloat(p[i]);
            }
            while (p.length > 0) {
                if (isNaN(p[0])) break;
                var cmd = null;
                var points = [];
                var startX = cpx, startY = cpy;
                switch (c) {
                  case "l":
                    cpx += p.shift();
                    cpy += p.shift();
                    cmd = "L";
                    points.push(cpx, cpy);
                    break;

                  case "L":
                    cpx = p.shift();
                    cpy = p.shift();
                    points.push(cpx, cpy);
                    break;

                  case "m":
                    cpx += p.shift();
                    cpy += p.shift();
                    cmd = "M";
                    points.push(cpx, cpy);
                    c = "l";
                    break;

                  case "M":
                    cpx = p.shift();
                    cpy = p.shift();
                    cmd = "M";
                    points.push(cpx, cpy);
                    c = "L";
                    break;

                  case "h":
                    cpx += p.shift();
                    cmd = "L";
                    points.push(cpx, cpy);
                    break;

                  case "H":
                    cpx = p.shift();
                    cmd = "L";
                    points.push(cpx, cpy);
                    break;

                  case "v":
                    cpy += p.shift();
                    cmd = "L";
                    points.push(cpx, cpy);
                    break;

                  case "V":
                    cpy = p.shift();
                    cmd = "L";
                    points.push(cpx, cpy);
                    break;

                  case "C":
                    points.push(p.shift(), p.shift(), p.shift(), p.shift());
                    cpx = p.shift();
                    cpy = p.shift();
                    points.push(cpx, cpy);
                    break;

                  case "c":
                    points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                    cpx += p.shift();
                    cpy += p.shift();
                    cmd = "C";
                    points.push(cpx, cpy);
                    break;

                  case "S":
                    var ctlPtx = cpx, ctlPty = cpy;
                    var prevCmd = ca[ca.length - 1];
                    if (prevCmd.command === "C") {
                        ctlPtx = cpx + (cpx - prevCmd.points[2]);
                        ctlPty = cpy + (cpy - prevCmd.points[3]);
                    }
                    points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                    cpx = p.shift();
                    cpy = p.shift();
                    cmd = "C";
                    points.push(cpx, cpy);
                    break;

                  case "s":
                    var ctlPtx = cpx, ctlPty = cpy;
                    var prevCmd = ca[ca.length - 1];
                    if (prevCmd.command === "C") {
                        ctlPtx = cpx + (cpx - prevCmd.points[2]);
                        ctlPty = cpy + (cpy - prevCmd.points[3]);
                    }
                    points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                    cpx += p.shift();
                    cpy += p.shift();
                    cmd = "C";
                    points.push(cpx, cpy);
                    break;

                  case "Q":
                    points.push(p.shift(), p.shift());
                    cpx = p.shift();
                    cpy = p.shift();
                    points.push(cpx, cpy);
                    break;

                  case "q":
                    points.push(cpx + p.shift(), cpy + p.shift());
                    cpx += p.shift();
                    cpy += p.shift();
                    cmd = "Q";
                    points.push(cpx, cpy);
                    break;

                  case "T":
                    var ctlPtx = cpx, ctlPty = cpy;
                    var prevCmd = ca[ca.length - 1];
                    if (prevCmd.command === "Q") {
                        ctlPtx = cpx + (cpx - prevCmd.points[0]);
                        ctlPty = cpy + (cpy - prevCmd.points[1]);
                    }
                    cpx = p.shift();
                    cpy = p.shift();
                    cmd = "Q";
                    points.push(ctlPtx, ctlPty, cpx, cpy);
                    break;

                  case "t":
                    var ctlPtx = cpx, ctlPty = cpy;
                    var prevCmd = ca[ca.length - 1];
                    if (prevCmd.command === "Q") {
                        ctlPtx = cpx + (cpx - prevCmd.points[0]);
                        ctlPty = cpy + (cpy - prevCmd.points[1]);
                    }
                    cpx += p.shift();
                    cpy += p.shift();
                    cmd = "Q";
                    points.push(ctlPtx, ctlPty, cpx, cpy);
                    break;

                  case "A":
                    var rx = p.shift(), ry = p.shift(), psi = p.shift(), fa = p.shift(), fs = p.shift();
                    var x1 = cpx, y1 = cpy;
                    cpx = p.shift(), cpy = p.shift();
                    cmd = "A";
                    points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                    break;

                  case "a":
                    var rx = p.shift(), ry = p.shift(), psi = p.shift(), fa = p.shift(), fs = p.shift();
                    var x1 = cpx, y1 = cpy;
                    cpx += p.shift(), cpy += p.shift();
                    cmd = "A";
                    points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                    break;
                }
                ca.push({
                    command: cmd || c,
                    points: points,
                    start: {
                        x: startX,
                        y: startY
                    },
                    pathLength: this.calcLength(startX, startY, cmd || c, points)
                });
            }
            if (c === "z" || c === "Z") {
                ca.push({
                    command: "z",
                    points: [],
                    start: undefined,
                    pathLength: 0
                });
            }
        }
        return ca;
    };
    Kinetic.Path.calcLength = function(x, y, cmd, points) {
        var len, p1, p2;
        var path = Kinetic.Path;
        switch (cmd) {
          case "L":
            return path.getLineLength(x, y, points[0], points[1]);

          case "C":
            len = 0;
            p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
            for (t = .01; t <= 1; t += .01) {
                p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
            }
            return len;

          case "Q":
            len = 0;
            p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
            for (t = .01; t <= 1; t += .01) {
                p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
            }
            return len;

          case "A":
            len = 0;
            var start = points[4];
            var dTheta = points[5];
            var end = points[4] + dTheta;
            var inc = Math.PI / 180;
            if (Math.abs(start - end) < inc) {
                inc = Math.abs(start - end);
            }
            p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
            if (dTheta < 0) {
                for (t = start - inc; t > end; t -= inc) {
                    p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
            } else {
                for (t = start + inc; t < end; t += inc) {
                    p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
            }
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            return len;
        }
        return 0;
    };
    Kinetic.Path.convertEndpointToCenterParameterization = function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
        var psi = psiDeg * (Math.PI / 180);
        var xp = Math.cos(psi) * (x1 - x2) / 2 + Math.sin(psi) * (y1 - y2) / 2;
        var yp = -1 * Math.sin(psi) * (x1 - x2) / 2 + Math.cos(psi) * (y1 - y2) / 2;
        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
        if (lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }
        var f = Math.sqrt((rx * rx * ry * ry - rx * rx * yp * yp - ry * ry * xp * xp) / (rx * rx * yp * yp + ry * ry * xp * xp));
        if (fa == fs) {
            f *= -1;
        }
        if (isNaN(f)) {
            f = 0;
        }
        var cxp = f * rx * yp / ry;
        var cyp = f * -ry * xp / rx;
        var cx = (x1 + x2) / 2 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
        var cy = (y1 + y2) / 2 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
        var vMag = function(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        };
        var vRatio = function(u, v) {
            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
        };
        var vAngle = function(u, v) {
            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
        };
        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
        var dTheta = vAngle(u, v);
        if (vRatio(u, v) <= -1) {
            dTheta = Math.PI;
        }
        if (vRatio(u, v) >= 1) {
            dTheta = 0;
        }
        if (fs === 0 && dTheta > 0) {
            dTheta = dTheta - 2 * Math.PI;
        }
        if (fs == 1 && dTheta < 0) {
            dTheta = dTheta + 2 * Math.PI;
        }
        return [ cx, cy, rx, ry, theta, dTheta, psi, fs ];
    };
    Kinetic.Node.addGetterSetter(Kinetic.Path, "data");
})();

(function() {
    var EMPTY_STRING = "", CALIBRI = "Calibri", NORMAL = "normal";
    Kinetic.TextPath = function(config) {
        this._initTextPath(config);
    };
    function _fillFunc(context) {
        context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
        context.strokeText(this.partialText, 0, 0);
    }
    Kinetic.TextPath.prototype = {
        _initTextPath: function(config) {
            var that = this;
            this.createAttrs();
            this.dummyCanvas = document.createElement("canvas");
            this.dataArray = [];
            Kinetic.Shape.call(this, config);
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this.shapeType = "TextPath";
            this._setDrawFuncs();
            this.dataArray = Kinetic.Path.parsePathData(this.attrs.data);
            this.on("dataChange", function() {
                that.dataArray = Kinetic.Path.parsePathData(this.attrs.data);
            });
            var attrs = [ "text", "textStroke", "textStrokeWidth" ];
            for (var n = 0; n < attrs.length; n++) {
                var attr = attrs[n];
                this.on(attr + "Change", that._setTextData);
            }
            that._setTextData();
        },
        drawFunc: function(canvas) {
            var charArr = this.charArr, context = canvas.getContext();
            context.font = this._getContextFont();
            context.textBaseline = "middle";
            context.textAlign = "left";
            context.save();
            var glyphInfo = this.glyphInfo;
            for (var i = 0; i < glyphInfo.length; i++) {
                context.save();
                var p0 = glyphInfo[i].p0;
                var p1 = glyphInfo[i].p1;
                var ht = parseFloat(this.attrs.fontSize);
                context.translate(p0.x, p0.y);
                context.rotate(glyphInfo[i].rotation);
                this.partialText = glyphInfo[i].text;
                canvas.fillStroke(this);
                context.restore();
            }
            context.restore();
        },
        getTextWidth: function() {
            return this.textWidth;
        },
        getTextHeight: function() {
            return this.textHeight;
        },
        setText: function(text) {
            Kinetic.Text.prototype.setText.call(this, text);
        },
        _getTextSize: function(text) {
            var dummyCanvas = this.dummyCanvas;
            var context = dummyCanvas.getContext("2d");
            context.save();
            context.font = this._getContextFont();
            var metrics = context.measureText(text);
            context.restore();
            return {
                width: metrics.width,
                height: parseInt(this.attrs.fontSize, 10)
            };
        },
        _setTextData: function() {
            var that = this;
            var size = this._getTextSize(this.attrs.text);
            this.textWidth = size.width;
            this.textHeight = size.height;
            this.glyphInfo = [];
            var charArr = this.attrs.text.split("");
            var p0, p1, pathCmd;
            var pIndex = -1;
            var currentT = 0;
            var getNextPathSegment = function() {
                currentT = 0;
                var pathData = that.dataArray;
                for (var i = pIndex + 1; i < pathData.length; i++) {
                    if (pathData[i].pathLength > 0) {
                        pIndex = i;
                        return pathData[i];
                    } else if (pathData[i].command == "M") {
                        p0 = {
                            x: pathData[i].points[0],
                            y: pathData[i].points[1]
                        };
                    }
                }
                return {};
            };
            var findSegmentToFitCharacter = function(c, before) {
                var glyphWidth = that._getTextSize(c).width;
                var currLen = 0;
                var attempts = 0;
                var needNextSegment = false;
                p1 = undefined;
                while (Math.abs(glyphWidth - currLen) / glyphWidth > .01 && attempts < 25) {
                    attempts++;
                    var cumulativePathLength = currLen;
                    while (pathCmd === undefined) {
                        pathCmd = getNextPathSegment();
                        if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {
                            cumulativePathLength += pathCmd.pathLength;
                            pathCmd = undefined;
                        }
                    }
                    if (pathCmd === {} || p0 === undefined) return undefined;
                    var needNewSegment = false;
                    switch (pathCmd.command) {
                      case "L":
                        if (Kinetic.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {
                            p1 = Kinetic.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
                        } else pathCmd = undefined;
                        break;

                      case "A":
                        var start = pathCmd.points[4];
                        var dTheta = pathCmd.points[5];
                        var end = pathCmd.points[4] + dTheta;
                        if (currentT === 0) currentT = start + 1e-8; else if (glyphWidth > currLen) currentT += Math.PI / 180 * dTheta / Math.abs(dTheta); else currentT -= Math.PI / 360 * dTheta / Math.abs(dTheta);
                        if (Math.abs(currentT) > Math.abs(end)) {
                            currentT = end;
                            needNewSegment = true;
                        }
                        p1 = Kinetic.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
                        break;

                      case "C":
                        if (currentT === 0) {
                            if (glyphWidth > pathCmd.pathLength) currentT = 1e-8; else currentT = glyphWidth / pathCmd.pathLength;
                        } else if (glyphWidth > currLen) currentT += (glyphWidth - currLen) / pathCmd.pathLength; else currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                        if (currentT > 1) {
                            currentT = 1;
                            needNewSegment = true;
                        }
                        p1 = Kinetic.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
                        break;

                      case "Q":
                        if (currentT === 0) currentT = glyphWidth / pathCmd.pathLength; else if (glyphWidth > currLen) currentT += (glyphWidth - currLen) / pathCmd.pathLength; else currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                        if (currentT > 1) {
                            currentT = 1;
                            needNewSegment = true;
                        }
                        p1 = Kinetic.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
                        break;
                    }
                    if (p1 !== undefined) {
                        currLen = Kinetic.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
                    }
                    if (needNewSegment) {
                        needNewSegment = false;
                        pathCmd = undefined;
                    }
                }
            };
            for (var i = 0; i < charArr.length; i++) {
                findSegmentToFitCharacter(charArr[i]);
                if (p0 === undefined || p1 === undefined) break;
                var width = Kinetic.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
                var kern = 0;
                var midpoint = Kinetic.Path.getPointOnLine(kern + width / 2, p0.x, p0.y, p1.x, p1.y);
                var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);
                this.glyphInfo.push({
                    transposeX: midpoint.x,
                    transposeY: midpoint.y,
                    text: charArr[i],
                    rotation: rotation,
                    p0: p0,
                    p1: p1
                });
                p0 = p1;
            }
        }
    };
    Kinetic.TextPath.prototype._getContextFont = Kinetic.Text.prototype._getContextFont;
    Kinetic.Global.extend(Kinetic.TextPath, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.TextPath, "fontFamily", CALIBRI);
    Kinetic.Node.addGetterSetter(Kinetic.TextPath, "fontSize", 12);
    Kinetic.Node.addGetterSetter(Kinetic.TextPath, "fontStyle", NORMAL);
    Kinetic.Node.addGetter(Kinetic.TextPath, "text", EMPTY_STRING);
})();

(function() {
    Kinetic.RegularPolygon = function(config) {
        this._initRegularPolygon(config);
    };
    Kinetic.RegularPolygon.prototype = {
        _initRegularPolygon: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "RegularPolygon";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var context = canvas.getContext(), sides = this.attrs.sides, radius = this.attrs.radius;
            context.beginPath();
            context.moveTo(0, 0 - radius);
            for (var n = 1; n < sides; n++) {
                var x = radius * Math.sin(n * 2 * Math.PI / sides);
                var y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
                context.lineTo(x, y);
            }
            context.closePath();
            canvas.fillStroke(this);
        }
    };
    Kinetic.Global.extend(Kinetic.RegularPolygon, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.RegularPolygon, "radius", 0);
    Kinetic.Node.addGetterSetter(Kinetic.RegularPolygon, "sides", 0);
})();

(function() {
    Kinetic.Star = function(config) {
        this._initStar(config);
    };
    Kinetic.Star.prototype = {
        _initStar: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "Star";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var context = canvas.getContext(), innerRadius = this.attrs.innerRadius, outerRadius = this.attrs.outerRadius, numPoints = this.attrs.numPoints;
            context.beginPath();
            context.moveTo(0, 0 - this.attrs.outerRadius);
            for (var n = 1; n < numPoints * 2; n++) {
                var radius = n % 2 === 0 ? outerRadius : innerRadius;
                var x = radius * Math.sin(n * Math.PI / numPoints);
                var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
                context.lineTo(x, y);
            }
            context.closePath();
            canvas.fillStroke(this);
        }
    };
    Kinetic.Global.extend(Kinetic.Star, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.Star, "numPoints", 0);
    Kinetic.Node.addGetterSetter(Kinetic.Star, "innerRadius", 0);
    Kinetic.Node.addGetterSetter(Kinetic.Star, "outerRadius", 0);
})();

(function() {
    var ATTR_CHANGE_LIST = [ "fontFamily", "fontSize", "fontStyle", "padding", "lineHeight", "text" ], CHANGE_KINETIC = "Change.kinetic", NONE = "none", UP = "up", RIGHT = "right", DOWN = "down", LEFT = "left", attrChangeListLen = ATTR_CHANGE_LIST.length;
    Kinetic.Label = function(config) {
        this._initLabel(config);
    };
    Kinetic.Label.prototype = {
        _initLabel: function(config) {
            var that = this, text = null;
            this.innerGroup = new Kinetic.Group();
            this.createAttrs();
            Kinetic.Group.call(this, config);
            text = new Kinetic.Text(config.text);
            this.setText(text);
            this.setRect(new Kinetic.LabelRect(config.rect));
            this.innerGroup.add(this.getRect());
            this.innerGroup.add(text);
            this.add(this.innerGroup);
            this._setGroupOffset();
            for (var n = 0; n < attrChangeListLen; n++) {
                text.on(ATTR_CHANGE_LIST[n] + CHANGE_KINETIC, function() {
                    that._setGroupOffset();
                });
            }
        },
        getWidth: function() {
            return this.getText().getWidth();
        },
        getHeight: function() {
            return this.getText().getHeight();
        },
        _setGroupOffset: function() {
            var text = this.getText(), width = text.getWidth(), height = text.getHeight(), rect = this.getRect(), pointerDirection = rect.getPointerDirection(), pointerWidth = rect.getPointerWidth(), pointerHeight = rect.getPointerHeight(), x = 0, y = 0;
            switch (pointerDirection) {
              case UP:
                x = width / 2;
                y = -1 * pointerHeight;
                break;

              case RIGHT:
                x = width + pointerWidth;
                y = height / 2;
                break;

              case DOWN:
                x = width / 2;
                y = height + pointerHeight;
                break;

              case LEFT:
                x = -1 * pointerWidth;
                y = height / 2;
                break;
            }
            this.setOffset({
                x: x,
                y: y
            });
        }
    };
    Kinetic.Global.extend(Kinetic.Label, Kinetic.Group);
    Kinetic.Node.addGetterSetter(Kinetic.Label, "text");
    Kinetic.Node.addGetterSetter(Kinetic.Label, "rect");
    Kinetic.LabelRect = function(config) {
        this._initLabelRect(config);
    };
    Kinetic.LabelRect.prototype = {
        _initLabelRect: function(config) {
            this.createAttrs();
            Kinetic.Shape.call(this, config);
            this.shapeType = "LabelRect";
            this._setDrawFuncs();
        },
        drawFunc: function(canvas) {
            var label = this.getParent().getParent(), context = canvas.getContext(), width = label.getWidth(), height = label.getHeight(), pointerDirection = this.getPointerDirection(), pointerWidth = this.getPointerWidth(), pointerHeight = this.getPointerHeight(), cornerRadius = this.getCornerRadius();
            context.beginPath();
            context.moveTo(0, 0);
            if (pointerDirection === UP) {
                context.lineTo((width - pointerWidth) / 2, 0);
                context.lineTo(width / 2, -1 * pointerHeight);
                context.lineTo((width + pointerWidth) / 2, 0);
            }
            context.lineTo(width, 0);
            if (pointerDirection === RIGHT) {
                context.lineTo(width, (height - pointerHeight) / 2);
                context.lineTo(width + pointerWidth, height / 2);
                context.lineTo(width, (height + pointerHeight) / 2);
            }
            context.lineTo(width, height);
            if (pointerDirection === DOWN) {
                context.lineTo((width + pointerWidth) / 2, height);
                context.lineTo(width / 2, height + pointerHeight);
                context.lineTo((width - pointerWidth) / 2, height);
            }
            context.lineTo(0, height);
            if (pointerDirection === LEFT) {
                context.lineTo(0, (height + pointerHeight) / 2);
                context.lineTo(-1 * pointerWidth, height / 2);
                context.lineTo(0, (height - pointerHeight) / 2);
            }
            context.closePath();
            canvas.fillStroke(this);
        }
    };
    Kinetic.Global.extend(Kinetic.LabelRect, Kinetic.Shape);
    Kinetic.Node.addGetterSetter(Kinetic.LabelRect, "pointerDirection", NONE);
    Kinetic.Node.addGetterSetter(Kinetic.LabelRect, "pointerWidth", 0);
    Kinetic.Node.addGetterSetter(Kinetic.LabelRect, "pointerHeight", 0);
    Kinetic.Node.addGetterSetter(Kinetic.LabelRect, "cornerRadius", 0);
})();

(function(window, jQuery, Kinetic) {
    var $ = jQuery;
    window.devicePixelRatio = 1;
    Kinetic.Node.prototype.closest = function(type) {
        var active = this.parent;
        while (active !== undefined) {
            if (active.nodeType === type) return active;
            active = active.parent;
        }
        return false;
    };
    Kinetic.Stage.prototype.createCopy = function() {
        var copy = [], children = this.getChildren(), i;
        for (i = 0; i < children.length; i++) {
            copy.push(children[i].clone());
        }
        return copy;
    };
    Kinetic.Stage.prototype.getScaledWidth = function() {
        return Math.ceil(this.getWidth() / this.getScale().x);
    };
    Kinetic.Stage.prototype.getScaledHeight = function() {
        return Math.ceil(this.getHeight() / this.getScale().y);
    };
    Kinetic.Stage.prototype.getSaveWidth = function() {
        return this.im.saveWidth;
    };
    Kinetic.Stage.prototype.getSaveHeight = function() {
        return this.im.saveHeight;
    };
    Kinetic.Stage.prototype.getTotalDimensions = function() {
        var minY = (this.getSaveHeight() / 2 - this.im.center.y) * this.getScale().y;
        var maxY = minY + this.getHeight() - this.getSaveHeight() * this.getScale().y;
        var minX = (this.getSaveWidth() / 2 - this.im.center.x) * this.getScale().x;
        var maxX = minX + this.getWidth() - this.getSaveWidth() * this.getScale().x;
        return {
            min: {
                x: minX,
                y: minY
            },
            max: {
                x: maxX,
                y: maxY
            },
            width: this.getScaledWidth(),
            height: this.getScaledHeight(),
            visibleWidth: Math.max(this.getSaveWidth(), this.getScaledWidth() * 2 - this.getSaveWidth()),
            visibleHeight: Math.max(this.getSaveHeight(), this.getScaledHeight() * 2 - this.getSaveHeight())
        };
    };
    Kinetic.Stage.prototype.loadCopy = function(copy) {
        var i;
        this.removeChildren();
        for (i = 0; i < copy.length; i++) {
            this.add(copy[i]);
        }
        this.draw();
    };
    Kinetic.Stage.prototype.elementType = "stage";
    Kinetic.Image.prototype.getImageData = function() {
        var canvas = new Kinetic.Canvas(this.attrs.image.width, this.attrs.image.height);
        var context = canvas.getContext();
        context.drawImage(this.attrs.image, 0, 0);
        try {
            var imageData = context.getImageData(0, 0, canvas.getWidth(), canvas.getHeight());
            return imageData;
        } catch (e) {
            Kinetic.Global.warn("Unable to get imageData.");
        }
    };
    Kinetic.Layer.prototype._cacheddraw = new Kinetic.Layer().draw;
    Kinetic.Layer.prototype.draw = function() {
        if (typeof im === "undefined" || typeof im.trigger === "undefined") {
            return this._cacheddraw();
        }
        var draw = this._cacheddraw();
        return draw;
    };
    Kinetic.Layer.prototype.elementType = "layer";
    Kinetic.Group.prototype.elementType = "group";
    Kinetic.Text.prototype.rasterize = function(e) {
        var layer = this.parent;
        var me = this;
        this.toImage({
            callback: function(img) {
                var rasterizedImage = new Kinetic.Image({
                    image: img,
                    x: me.getPosition().x,
                    y: me.getPosition().y
                });
                me.remove();
                layer.add(rasterizedImage).draw();
                e.callback(rasterizedImage);
            }
        });
    };
    Kinetic.Global.extend(Kinetic.Container, Kinetic.Node);
    Kinetic.Global.extend(Kinetic.Shape, Kinetic.Node);
    Kinetic.Global.extend(Kinetic.Group, Kinetic.Container);
    Kinetic.Global.extend(Kinetic.Layer, Kinetic.Container);
    Kinetic.Global.extend(Kinetic.Stage, Kinetic.Container);
    Kinetic.Global.extend(Kinetic.Circle, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Ellipse, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Image, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Line, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Path, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Polygon, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Rect, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.RegularPolygon, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Sprite, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Star, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Text, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.TextPath, Kinetic.Shape);
    Kinetic.Global.extend(Kinetic.Wedge, Kinetic.Shape);
    var ImageEditor = function(settings) {
        "use strict";
        if (settings === undefined) return this;
        settings.pixelRatio = 1;
        var im = this, x, round = function(float) {
            return Math.round(float);
        };
        im.width = settings.width;
        im.height = settings.height;
        im.saveWidth = settings.saveWidth || round(im.width / 2);
        im.saveHeight = settings.saveHeight || round(im.height / 2);
        im.strictSize = settings.saveWidth !== undefined ? true : false;
        im.stage = new Kinetic.Stage(settings);
        im.namespaces = {};
        im.controlSets = {};
        im.components = {};
        im.settings = settings;
        im.filters = {};
        im.scale = 1;
        im.crosshair = new Image();
        im.uniqid = im.stage.getContainer().id;
        im.editorContext = $(im.stage.getContainer()).parent();
        im.domContext = im.editorContext.parent();
        im.controlContext = im.domContext.children("div.controls");
        im.showLoader = $.fn.dialog.showLoader;
        im.hideLoader = $.fn.dialog.hideLoader;
        im.stage.im = im;
        im.stage.setX(.5);
        im.stage.setY(.5);
        im.stage.elementType = "stage";
        im.crosshair.src = "/concrete/images/image_editor/crosshair.png";
        im.center = {
            x: Math.round(im.width / 2),
            y: Math.round(im.height / 2)
        };
        im.centerOffset = {
            x: im.center.x,
            y: im.center.y
        };
        var getElem = function(selector) {
            return $(selector, im.domContext);
        }, log = function() {
            if (settings.debug === true && console !== undefined) {
                var args = arguments;
                if (args.length == 1) args = args[0];
                console.log(args);
            }
        }, warn = function() {
            if (settings.debug === true && console !== undefined) {
                var args = arguments;
                if (args.length == 1) args = args[0];
                console.warn(args);
            }
        }, error = function() {
            if (console !== undefined) {
                var args = arguments;
                if (args.length == 1) args = args[0];
                console.error("Image Editor Error: " + args);
            }
        };
        im.stage._setDraggable = im.stage.setDraggable;
        im.stage.setDraggable = function(v) {
            warn("setting draggable to " + v);
            return im.stage._setDraggable(v);
        };
        var History = function() {
            var h = this;
            h.history = [];
            h.pointer = -1;
            h.save = function() {
                im.fire("beforehistorysave");
                h.history = h.history.slice(0, h.pointer + 1);
                h.history.push(im.stage.createCopy());
                h.movePointer(1);
                im.fire("historysave");
            };
            h.movePointer = function(diff) {
                h.pointer += diff;
                h.pointer < 0 && (h.pointer = 0);
                h.pointer >= h.history.length && (h.pointer = h.history.length - 1);
                return h.pointer;
            };
            h.render = function() {
                im.fire("beforehistoryrender");
                im.stage.loadCopy(h.history[h.pointer]);
                im.fire("historyrender");
            };
            h.undo = function() {
                im.fire("beforehistoryundo");
                h.movePointer(-1);
                h.render();
                im.fire("historyundo");
            };
            h.redo = function() {
                im.fire("beforehistoryredo");
                h.movePointer(1);
                h.render();
                im.fire("historyredo");
            };
        };
        im.history = new History();
        im.bindEvent = im.bind = im.on = function(type, handler, elem) {
            var element = elem || im.stage.getContainer();
            if (element instanceof jQuery) element = element[0];
            ccm_event.sub(type, handler, element);
        };
        im.fireEvent = im.fire = im.trigger = function(type, data, elem) {
            var element = elem || im.stage.getContainer();
            if (element instanceof jQuery) element = element[0];
            ccm_event.pub(type, data, element);
        };
        im.addElement = function(object, type) {
            var layer = new Kinetic.Layer();
            layer.elementType = layer;
            layer.add(object);
            object.setOffset([ object.getWidth() / 2, object.getHeight() / 2 ]);
            layer.setOffset([ -object.getWidth() / 2, -object.getHeight() / 2 ]);
            object.setX(im.center.x - Math.round(object.getWidth() / 2));
            object.setY(im.center.y - Math.round(object.getHeight() / 2));
            object.doppelganger = object.clone();
            if (type == "image") object.doppelganger.setImage("");
            object.doppelganger.doppelganger = object;
            object.doppelganger.drawHitFunc = object.doppelganger.attrs.drawHitFunc = function() {
                return false;
            };
            object.doppelganger.setFill("transparent");
            object.doppelganger.elementType = "StokeClone";
            object.doppelganger.setStroke("blue");
            object.doppelganger._drawFunc = object.getDrawFunc();
            object.doppelganger.setListening(false);
            object.doppelganger.setDrawFunc(function(canvas) {
                if (typeof this._drawFunc == "function") {
                    this.setStrokeWidth(1 / im.scale);
                    this.setFill("transparent");
                    if (type == "image") {
                        this.attrs.image = "";
                    }
                    this._drawFunc(canvas);
                }
            });
            object.elementType = type;
            object.on("click", function() {
                im.fire("ClickedElement", this);
            });
            object._drawFunc = object.getDrawFunc();
            object.setDrawFunc(function(canvas) {
                for (var attr in this.attrs) {
                    if (attr == "drawFunc" || attr == "drawHitFunc" || attr == "strokeWidth" || attr == "fill" || attr == "listening") continue;
                    this.doppelganger.attrs[attr] = this.attrs[attr];
                }
                var offset = this.getOffset();
                this.doppelganger.setX(this.getX() + offset.x);
                this.doppelganger.setY(this.getY() + offset.y);
                this.doppelganger.setOffset(this.getOffset());
                this.doppelganger.setSize(this.getSize());
                im.foreground.draw();
                this._drawFunc(canvas);
            });
            object.on("mouseover", function() {
                this.hovered = true;
                im.setCursor("pointer");
            });
            object.on("mouseout", function() {
                if (this.hovered == true) {
                    im.setCursor("");
                    this.hovered = false;
                }
            });
            im.stage.add(layer);
            im.fire("newObject", {
                object: object,
                type: type
            });
            im.foreground.moveToTop();
            im.stage.draw();
        };
        im.on("backgroundBuilt", function() {
            if (im.activeElement !== undefined && im.activeElement.doppelganger !== undefined) {
                im.foreground.add(im.activeElement.doppelganger);
                im.activeElement.doppelganger.setPosition(im.activeElement.getPosition());
            }
        });
        im.setActiveElement = function(element) {
            if (element.defer) {
                return im.setActiveElement(element.defer);
            }
            if (im.activeElement == element) return;
            if (im.activeElement !== undefined && im.activeElement.doppelganger !== undefined) {
                im.activeElement.doppelganger.remove();
            }
            if (element === im.stage || element.nodeType == "Stage") {
                im.trigger("ChangeActiveAction", "ControlSet_Position");
                $("div.control-sets", im.controlContext).find("h4.active").removeClass("active");
            } else if (element.doppelganger !== undefined) {
                im.foreground.add(element.doppelganger);
                im.foreground.draw();
            }
            im.trigger("beforeChangeActiveElement", im.activeElement);
            im.alterCore("activeElement", element);
            im.trigger("changeActiveElement", element);
            im.stage.draw();
        };
        im.bind("ClickedElement", function(e) {
            im.setActiveElement(e.eventData);
        });
        im.bind("stageChanged", function(e) {
            if (im.activeElement.getWidth() > im.stage.getScaledWidth() || im.activeElement.getHeight() > im.stage.getScaledHeight()) {
                im.setActiveElement(im.stage);
            }
        });
        var controlBar = getElem(im.stage.getContainer()).parent().children(".bottomBar");
        controlBar.attr("unselectable", "on");
        var zoom = {};
        zoom.in = getElem("<div class='bottombarbutton plus'><i class='icon-plus'></i></div>");
        zoom.out = getElem("<div class='bottombarbutton'><i class='icon-minus'></i></div>");
        zoom.in.appendTo(controlBar);
        zoom.out.appendTo(controlBar);
        zoom.in.click(function(e) {
            im.fire("zoomInClick", e);
        });
        zoom.out.click(function(e) {
            im.fire("zoomOutClick", e);
        });
        var scale = getElem("<div></div>").addClass("scale").text("100%");
        im.on("scaleChange", function(e) {
            scale.text(Math.round(im.scale * 1e4) / 100 + "%");
        });
        scale.click(function() {
            im.scale = 1;
            im.stage.setScale(im.scale);
            var pos = im.stage.getDragBoundFunc()({
                x: im.stage.getX(),
                y: im.stage.getY()
            });
            im.stage.setX(pos.x);
            im.stage.setY(pos.y);
            im.fire("scaleChange");
            im.buildBackground();
            im.stage.draw();
        });
        scale.appendTo(controlBar);
        var minScale = 0, maxScale = 3e3, stepScale = 5 / 6;
        im.on("zoomInClick", function(e) {
            var centerx = (-im.stage.getX() + im.stage.getWidth() / 2) / im.scale, centery = (-im.stage.getY() + im.stage.getHeight() / 2) / im.scale;
            im.scale /= stepScale;
            im.scale = Math.round(im.scale * 1e3) / 1e3;
            im.alterCore("scale", im.scale);
            var ncenterx = (-im.stage.getX() + im.stage.getWidth() / 2) / im.scale, ncentery = (-im.stage.getY() + im.stage.getHeight() / 2) / im.scale;
            im.stage.setX(im.stage.getX() - (centerx - ncenterx) * im.scale);
            im.stage.setY(im.stage.getY() - (centery - ncentery) * im.scale);
            im.stage.setScale(im.scale);
            var pos = im.stage.getDragBoundFunc()({
                x: im.stage.getX(),
                y: im.stage.getY()
            });
            im.stage.setX(pos.x);
            im.stage.setY(pos.y);
            im.fire("scaleChange");
            im.buildBackground();
            im.stage.draw();
        });
        im.on("zoomOutClick", function(e) {
            var centerx = (-im.stage.getX() + im.stage.getWidth() / 2) / im.scale, centery = (-im.stage.getY() + im.stage.getHeight() / 2) / im.scale;
            im.scale *= stepScale;
            im.scale = Math.round(im.scale * 1e3) / 1e3;
            im.alterCore("scale", im.scale);
            var ncenterx = (-im.stage.getX() + im.stage.getWidth() / 2) / im.scale, ncentery = (-im.stage.getY() + im.stage.getHeight() / 2) / im.scale;
            im.stage.setX(im.stage.getX() - (centerx - ncenterx) * im.scale);
            im.stage.setY(im.stage.getY() - (centery - ncentery) * im.scale);
            im.stage.setScale(im.scale);
            var pos = im.stage.getDragBoundFunc()({
                x: im.stage.getX(),
                y: im.stage.getY()
            });
            im.stage.setX(pos.x);
            im.stage.setY(pos.y);
            im.fire("scaleChange");
            im.buildBackground();
            im.stage.draw();
        });
        var saveSize = {};
        saveSize.width = getElem("<span/>").addClass("saveWidth");
        saveSize.height = getElem("<span/>").addClass("saveHeight");
        saveSize.crop = getElem('<div><i class="icon-resize-full"/></div>').addClass("bottombarbutton").addClass("crop");
        saveSize.both = saveSize.height.add(saveSize.width).width(32).attr("contenteditable", !!1);
        saveSize.area = getElem("<span/>").css({
            "float": "right"
        });
        saveSize.crop.appendTo(saveSize.area);
        saveSize.width.appendTo($("<div>w </div>").addClass("saveWidth").appendTo(saveSize.area));
        saveSize.height.appendTo($("<div>h </div>").addClass("saveHeight").appendTo(saveSize.area));
        saveSize.area.appendTo(controlBar);
        im.on("adjustedsavers", function() {
            saveSize.width.text(im.saveWidth);
            saveSize.height.text(im.saveHeight);
        });
        saveSize.crop.click(function() {
            im.adjustSavers();
        });
        if (im.strictSize) {
            saveSize.both.attr("disabled", "true");
        } else {
            saveSize.both.keyup(function(e) {
                im.fire("editedSize", e);
            });
        }
        im.bind("editedSize", function(e) {
            im.saveWidth = parseInt(saveSize.width.text());
            im.saveHeight = parseInt(saveSize.height.text());
            if (isNaN(im.saveWidth)) im.saveWidth = 0;
            if (isNaN(im.saveHeight)) im.saveHeight = 0;
            im.buildBackground();
        });
        im.bind("saveSizeChange", function() {
            saveSize.width.text(im.saveWidth);
            saveSize.height.text(im.saveHeight);
        });
        im.setCursor = function(cursor) {
            $(im.stage.getContainer()).css("cursor", cursor);
        };
        im.save = function() {
            im.background.hide();
            if (im.activeElement !== undefined && typeof im.activeElement.releaseStroke == "function") {
                im.activeElement.releaseStroke();
            }
            im.stage.setScale(1);
            im.setActiveElement(im.stage);
            im.fire("ChangeActiveAction");
            im.fire("changeActiveComponent");
            im.background.hide();
            im.foreground.hide();
            $(im.stage.getContainer()).hide();
            var startx = Math.round(im.center.x - im.saveWidth / 2), starty = Math.round(im.center.y - im.saveHeight / 2), oldx = im.stage.getX(), oldy = im.stage.getY(), oldwidth = im.stage.getWidth(), oldheight = im.stage.getHeight();
            im.stage.setX(-startx);
            im.stage.setY(-starty);
            im.stage.setWidth(Math.max(im.stage.getWidth(), im.saveWidth));
            im.stage.setHeight(Math.max(im.stage.getHeight(), im.saveHeight));
            im.stage.draw();
            im.showLoader("Saving..");
            im.stage.toDataURL({
                width: im.saveWidth,
                height: im.saveHeight,
                callback: function(data) {
                    var img = $("<img/>").attr("src", data);
                    $.fn.dialog.open({
                        element: $(img).width(250)
                    });
                    im.hideLoader();
                    im.background.show();
                    im.foreground.show();
                    im.stage.setX(oldx);
                    im.stage.setY(oldy);
                    im.stage.setWidth(oldwidth);
                    im.stage.setHeight(oldheight);
                    im.stage.setScale(im.scale);
                    im.stage.draw();
                    $(im.stage.getContainer()).show();
                }
            });
        };
        im.adjustSavers = function() {
            im.foreground.autoCrop = false;
            im.background.autoCrop = false;
            var i, e, c = im.stage.getChildren(), l = c.length, count = {
                min: {
                    x: false,
                    y: false
                },
                max: {
                    x: false,
                    y: false
                }
            };
            for (i = 0; i < l; i++) {
                if (c[i].autoCrop === false) continue;
                for (e in c[i].children) {
                    var pos = c[i].children[e].getPosition(), size = c[i].children[e].getSize(), center = {
                        x: pos.x + size.width / 2,
                        y: pos.y + size.height / 2
                    };
                    if (count.min.x === false) {
                        count.min.x = pos.x;
                        count.min.y = pos.y;
                        count.max.x = pos.x - size.width;
                        count.max.y = pos.y + size.height;
                    }
                    if (count.min.x > pos.x) count.min.x = pos.x;
                    if (count.min.y > pos.y) count.min.y = pos.y;
                    if (count.max.x < pos.x + size.width) count.max.x = pos.x + size.width;
                    if (count.max.y < pos.y + size.height) count.max.y = pos.y + size.height;
                }
            }
            var avg = {
                x: (count.min.x + count.max.x) / 2,
                y: (count.min.y + count.max.y) / 2
            }, diff = {
                x: Math.round(avg.x - im.center.x),
                y: Math.round(avg.y - im.center.y)
            };
            if (count.min.x === false) {
                im.alterCore("saveWidth", 0);
                im.alterCore("saveHeight", 0);
                im.buildBackground();
                im.fire("adjustedsavers");
                return;
            }
            if (diff.x !== 0 || diff.y !== 0) {
                for (i = 0; i < l; i++) {
                    if (c[i].autoCrop === false) continue;
                    for (e in c[i].children) {
                        c[i].children[e].attrs.x -= diff.x;
                        c[i].children[e].attrs.y -= diff.y;
                    }
                }
                return im.adjustSavers();
            }
            var size = {
                width: count.max.x - count.min.x,
                height: count.max.y - count.min.y
            };
            console.log(size);
            im.alterCore("saveWidth", Math.round(size.width));
            im.alterCore("saveHeight", Math.round(size.height));
            im.buildBackground();
            im.fire("adjustedsavers");
            im.stage.draw();
        };
        im.extend = function(property, value) {
            this[property] = value;
        };
        im.alterCore = function(property, value) {
            var nim = im, ns = "core", i;
            if (im.namespace) {
                var ns = nim.namespace;
                nim = im.realIm;
            }
            im[property] = value;
            for (i in im.controlSets) {
                im.controlSets[i].im.extend(property, value);
            }
            for (i in im.filters) {
                im.filters[i].im.extend(property, value);
            }
            for (i in im.components) {
                im.components[i].im.extend(property, value);
            }
        };
        im.clone = function(namespace) {
            var newim = new ImageEditor(), i;
            newim.realIm = im;
            for (i in im) {
                newim[i] = im[i];
            }
            newim.namespace = namespace;
            return newim;
        };
        im.addControlSet = function(ns, js, elem) {
            if (jQuery && elem instanceof jQuery) elem = elem[0];
            elem.controlSet = function(im, js) {
                im.disable = function() {
                    im.enabled = false;
                    $(elem).parent().parent().addClass("disabled");
                };
                im.enable = function() {
                    im.enabled = true;
                    $(elem).parent().parent().removeClass("disabled");
                };
                this.im = im;
                warn("Loading ControlSet", im);
                try {
                    eval(js);
                } catch (e) {
                    var pos = e.stack.replace(/[\S\s]+at HTMLDivElement.eval.+?<anonymous>:(\d+:\d+)[\S\s]+/, "$1").split(":");
                    if (pos[1] && !isNaN(parseInt(pos[1]))) {
                        var jsstack = js.split("\n");
                        var msg = "Parse error at line #" + pos[0] + " char #" + pos[1] + " within " + ns;
                        msg += "\n" + jsstack[parseInt(pos[0]) - 1];
                        msg += "\n" + new Array(parseInt(pos[1])).join(" ") + "^";
                        error(msg);
                    } else {
                        error('"' + e.message + '" in "' + im.namespace + '"');
                    }
                }
                return this;
            };
            var newim = im.clone(ns);
            var nso = elem.controlSet.call(elem, newim, js);
            im.controlSets[ns] = nso;
            return nso;
        };
        im.addFilter = function(ns, js) {
            var filter = function(im, js) {
                this.namespace = im.namespace;
                this.im = im;
                try {
                    eval(js);
                } catch (e) {
                    error(e);
                    window.lastError = e;
                    var pos = e.stack.replace(/[\S\s]+at HTMLDivElement.eval.+?<anonymous>:(\d+:\d+)[\S\s]+/, "$1").split(":");
                    if (pos.length != 2) {
                        error(e.message);
                        error(e.stack);
                    } else {
                        var jsstack = js.split("\n");
                        var msg = "Parse error at line #" + pos[0] + " char #" + pos[1] + " within " + ns;
                        msg += "\n" + jsstack[parseInt(pos[0]) - 1];
                        msg += "\n" + new Array(parseInt(pos[1]) || 0).join(" ") + "^";
                        error(msg);
                    }
                }
                return this;
            };
            var newim = im.clone(ns);
            var nso = new filter(newim, js);
            im.filters[ns] = nso;
            return nso;
        };
        im.addComponent = function(ns, js, elem) {
            if (jQuery && elem instanceof jQuery) elem = elem[0];
            elem.component = function(im, js) {
                im.disable = function() {
                    $(this).parent().parent().addClass("disabled");
                };
                im.enable = function() {
                    $(this).parent().parent().removeClass("disabled");
                };
                this.im = im;
                warn("Loading component", im);
                try {
                    eval(js);
                } catch (e) {
                    var pos = e.stack.replace(/[\S\s]+at HTMLDivElement.eval.+?<anonymous>:(\d+:\d+)[\S\s]+/, "$1").split(":");
                    if (pos[1] && !isNaN(parseInt(pos[1]))) {
                        var jsstack = js.split("\n");
                        var msg = "Parse error at line #" + pos[0] + " char #" + pos[1] + " within " + ns;
                        msg += "\n" + jsstack[parseInt(pos[0]) - 1];
                        msg += "\n" + new Array(parseInt(pos[1])).join(" ") + "^";
                        error(msg);
                    } else {
                        error('"' + e.message + '" in "' + im.namespace + '"');
                    }
                }
                return this;
            };
            var newim = im.clone(ns);
            var nso = elem.component.call(elem, newim, js);
            im.components[ns] = nso;
            return nso;
        };
        im.background = new Kinetic.Layer();
        im.foreground = new Kinetic.Layer();
        im.stage.add(im.background);
        im.stage.add(im.foreground);
        im.bgimage = new Image();
        im.saveArea = new Kinetic.Rect();
        im.bgimage.onload = function() {
            im.saveArea.setFillPatternImage(im.bgimage);
            im.saveArea.setFillPatternOffset([ -(im.saveWidth / 2), -(im.saveHeight / 2) ]);
            im.saveArea.setFillPatternScale(1 / im.scale);
            im.saveArea.setFillPatternX(0);
            im.saveArea.setFillPatternY(0);
            im.saveArea.setFillPatternRepeat("repeat");
            im.background.add(im.saveArea);
            im.background.on("click", function() {
                im.setActiveElement(im.stage);
            });
        };
        im.bgimage.src = "/concrete/images/testbg.png";
        im.buildBackground = function() {
            var startbb = new Date().getTime();
            var dimensions = im.stage.getTotalDimensions();
            var to = (dimensions.max.x + dimensions.visibleHeight + dimensions.visibleWidth) * 2;
            im.saveArea.setFillPatternOffset([ -(im.saveWidth / 2) * im.scale, -(im.saveHeight / 2) * im.scale ]);
            im.saveArea.setX(Math.floor(im.center.x - im.saveWidth / 2));
            im.saveArea.setY(Math.floor(im.center.y - im.saveHeight / 2));
            im.saveArea.setFillPatternScale(1 / im.scale);
            im.saveArea.setWidth(im.saveWidth);
            im.saveArea.setHeight(im.saveHeight);
            if (im.foreground) {
                im.foreground.destroy();
            }
            im.foreground = new Kinetic.Layer();
            im.stage.add(im.foreground);
            if (!im.coverLayer) {
                im.coverLayer = new Kinetic.Rect();
                im.coverLayer.setStroke("rgba(150,150,150,.5)");
                im.coverLayer.setFill("transparent");
                im.coverLayer.setListening(false);
                im.coverLayer.setStrokeWidth(Math.max(dimensions.width, dimensions.height, 500));
            }
            var width = Math.max(dimensions.width, dimensions.height) * 2;
            im.coverLayer.attrs.width = im.saveArea.attrs.width + width;
            im.coverLayer.attrs.height = im.saveArea.attrs.height + width;
            im.coverLayer.attrs.x = im.saveArea.attrs.x - width / 2;
            im.coverLayer.attrs.y = im.saveArea.attrs.y - width / 2;
            im.coverLayer.setStrokeWidth(width);
            im.foreground.add(im.coverLayer);
            im.fire("backgroundBuilt");
            im.background.draw();
            im.foreground.draw();
            if (im.activeElement && im.activeElement.elementType != "stage" && im.activeElement.parent) {
                im.activeElement.parent.draw();
            }
        };
        im.buildBackground();
        im.on("stageChanged", im.buildBackground);
        im.stage.setDragBoundFunc(function(ret) {
            var dim = im.stage.getTotalDimensions();
            var maxx = Math.max(dim.max.x, dim.min.x) - 1, minx = Math.min(dim.max.x, dim.min.x) + 1, maxy = Math.max(dim.max.y, dim.min.y) - 1, miny = Math.min(dim.max.y, dim.min.y) + 1;
            ret.x = Math.floor(ret.x);
            ret.y = Math.floor(ret.y);
            if (ret.x > maxx) ret.x = maxx;
            if (ret.x < minx) ret.x = minx;
            if (ret.y > maxy) ret.y = maxy;
            if (ret.y < miny) ret.y = miny;
            ret.x = Math.floor(ret.x);
            ret.y = Math.floor(ret.y);
            return ret;
        });
        im.setActiveElement(im.stage);
        im.stage.setDraggable(true);
        im.autoCrop = true;
        im.on("imageLoad", function() {
            var padding = 100;
            var w = im.stage.getWidth() - padding * 2, h = im.stage.getHeight() - padding * 2;
            if (im.saveWidth < w && im.saveHeight < h) return;
            var perc = Math.max(im.saveWidth / w, im.saveHeight / h);
            im.stage.setX((im.stage.getWidth() - im.stage.getWidth() * im.stage.getScale().x) / 2);
            im.stage.setY((im.stage.getHeight() - im.stage.getHeight() * im.stage.getScale().y) / 2);
            var pos = im.stage.getDragBoundFunc()({
                x: im.stage.getX(),
                y: im.stage.getY()
            });
            im.stage.setX(pos.x);
            im.stage.setY(pos.y);
            im.fire("scaleChange");
            im.fire("stageChanged");
            im.buildBackground();
        });
        im.fit = function(wh, scale) {
            if (scale === false) {
                return {
                    width: im.saveWidth,
                    height: im.saveHeight
                };
            }
            var height = wh.height, width = wh.width;
            if (width > im.saveWidth) {
                height /= width / im.saveWidth;
                width = im.saveWidth;
            }
            if (height > im.saveHeight) {
                width /= height / im.saveHeight;
                height = im.saveHeight;
            }
            return {
                width: width,
                height: height
            };
        };
        if (settings.src) {
            im.showLoader("Loading Image..");
            var img = new Image();
            img.src = settings.src;
            img.onload = function() {
                if (!im.strictSize) {
                    im.saveWidth = img.width;
                    im.saveHeight = img.height;
                    im.fire("saveSizeChange");
                    im.buildBackground();
                }
                var center = {
                    x: Math.floor(im.center.x - img.width / 2),
                    y: Math.floor(im.center.y - img.height / 2)
                };
                var image = new Kinetic.Image({
                    image: img,
                    x: Math.floor(center.x),
                    y: Math.floor(center.y)
                });
                im.fire("imageload");
                im.addElement(image, "image");
            };
        } else {
            im.fire("imageload");
        }
        im.bind("imageload", function() {
            var cs = settings.controlsets || {}, filters = settings.filters || {}, namespace, firstcs;
            var running = 0;
            log("Loading ControlSets");
            im.showLoader("Loading Control Sets..");
            im.fire("LoadingControlSets");
            for (namespace in cs) {
                var myns = "ControlSet_" + namespace;
                $.ajax(cs[namespace]["src"], {
                    dataType: "text",
                    cache: false,
                    namespace: namespace,
                    myns: myns,
                    beforeSend: function() {
                        running++;
                    },
                    success: function(js) {
                        running--;
                        var nso = im.addControlSet(this.myns, js, cs[this.namespace]["element"]);
                        log(nso);
                        im.fire("controlSetLoad", nso);
                        if (0 == running) {
                            im.trigger("ControlSetsLoaded");
                        }
                    },
                    error: function(xhr, errDesc, exception) {
                        running--;
                        if (0 == running) {
                            im.trigger("ControlSetsLoaded");
                        }
                    }
                });
            }
        });
        im.bind("ControlSetsLoaded", function() {
            im.fire("LoadingComponents");
            im.showLoader("Loading Components..");
            var components = settings.components || {}, namespace, running = 0;
            log("Loading Components");
            for (namespace in components) {
                var myns = "Component_" + namespace;
                $.ajax(components[namespace]["src"], {
                    dataType: "text",
                    cache: false,
                    namespace: namespace,
                    myns: myns,
                    beforeSend: function() {
                        running++;
                    },
                    success: function(js) {
                        running--;
                        var nso = im.addComponent(this.myns, js, components[this.namespace]["element"]);
                        log(nso);
                        im.fire("ComponentLoad", nso);
                        if (0 == running) {
                            im.trigger("ComponentsLoaded");
                        }
                    },
                    error: function(xhr, errDesc, exception) {
                        running--;
                        if (0 == running) {
                            im.trigger("ComponentsLoaded");
                        }
                    }
                });
            }
        });
        im.bind("ComponentsLoaded", function() {
            log("Loading Filters");
            im.showLoader("Loading Filters..");
            var filters = settings.filters || {}, namespace, firstf, firstc, active = 0;
            im.fire("LoadingFilters");
            for (namespace in filters) {
                var myns = "Filter_" + namespace;
                var name = filters[namespace].name;
                if (!firstf) firstf = myns;
                active++;
                $.ajax(filters[namespace].src, {
                    dataType: "text",
                    cache: false,
                    namespace: namespace,
                    myns: myns,
                    name: name,
                    success: function(js) {
                        var nso = im.addFilter(this.myns, js);
                        nso.name = this.name;
                        im.fire("filterLoad", nso);
                        active--;
                        if (0 == active) {
                            im.trigger("FiltersLoaded");
                        }
                    },
                    error: function(xhr, errDesc, exception) {
                        active--;
                        if (0 == active) {
                            im.trigger("FiltersLoaded");
                        }
                    }
                });
            }
        });
        im.bind("ChangeActiveAction", function(e) {
            var ns = e.eventData;
            if (ns === im.activeControlSet) return;
            for (var ons in im.controlSets) {
                getElem(im.controlSets[ons]);
                if (ons !== ns) getElem(im.controlSets[ons]).slideUp();
            }
            im.activeControlSet = ns;
            im.alterCore("activeControlSet", ns);
            if (!ns) {
                $("div.control-sets", im.controlContext).find("h4.active").removeClass("active");
                return;
            }
            var cs = $(im.controlSets[ns]), height = cs.show().height();
            if (cs.length == 0) return;
            cs.hide().height(height).slideDown(function() {
                $(this).height("");
            });
        });
        im.bind("ChangeActiveComponent", function(e) {
            var ns = e.eventData;
            if (ns === im.activeComponent) return;
            for (var ons in im.components) {
                if (ons !== ns) getElem(im.components[ons]).slideUp();
            }
            im.activeComponent = ns;
            im.alterCore("activeComponent", ns);
            if (!ns) return;
            var cs = $(im.components[ns]), height = cs.show().height();
            if (cs.length == 0) return;
            cs.hide().height(height).slideDown(function() {
                $(this).height("");
            });
        });
        im.bind("ChangeNavTab", function(e) {
            log("changenavtab", e);
            im.trigger("ChangeActiveAction", e.eventData);
            im.trigger("ChangeActiveComponent", e.eventData);
            var parent = getElem("div.editorcontrols");
            switch (e.eventData) {
              case "add":
                parent.children("div.control-sets").hide();
                parent.children("div.components").show();
                break;

              case "edit":
                parent.children("div.components").hide();
                parent.children("div.control-sets").show();
                break;
            }
        });
        im.bind("FiltersLoaded", function() {
            im.hideLoader();
        });
        im.slideOut = $("<div/>").addClass("slideOut").css({
            width: 0,
            "float": "right",
            height: "100%",
            "overflow-x": "hidden",
            right: im.controlContext.width() - 1,
            position: "absolute",
            background: "white",
            "box-shadow": "black -20px 0 20px -25px"
        });
        im.slideOutContents = $("<div/>").appendTo(im.slideOut).width(300);
        im.showSlideOut = function(contents, callback) {
            im.hideSlideOut(function() {
                im.slideOut.empty();
                im.slideOutContents = contents.width(300);
                im.slideOut.append(im.slideOutContents);
                im.slideOut.addClass("active").addClass("sliding");
                im.slideOut.stop(1).slideOut(300, function() {
                    im.slideOut.removeClass("sliding");
                    typeof callback === "function" && callback();
                });
            });
        };
        im.hideSlideOut = function(callback) {
            im.slideOut.addClass("sliding");
            im.slideOut.slideIn(300, function() {
                im.slideOut.css("border-right", "0");
                im.slideOut.removeClass("active").removeClass("sliding");
                typeof callback === "function" && callback();
            });
        };
        im.controlContext.after(im.slideOut);
        im.setActiveElement(im.stage);
        window.c5_image_editor = im;
        window.im = im;
        return im;
    };
    $.fn.ImageEditor = function(settings) {
        settings === undefined && (settings = {});
        settings.imageload = $.fn.dialog.hideLoader;
        var self = $(this);
        settings.container = self[0];
        if (self.height() == 0) {
            setTimeout(function() {
                self.ImageEditor(settings);
            }, 50);
            return;
        }
        self.closest(".ui-dialog").find(".ui-resizable-handle").hide();
        self.height("-=30");
        $("div.editorcontrols").height(self.height() - 130);
        self.width("-=330").parent().width("-=330").children("div.bottomBar").width("-=330");
        settings.width === undefined && (settings.width = self.width());
        settings.height === undefined && (settings.height = self.height());
        $.fn.dialog.showLoader();
        var im = new ImageEditor(settings);
        var context = im.domContext;
        im.on("ChangeActiveAction", function(e) {
            if (!e.eventData) $("h4.active", context).removeClass("active");
        });
        im.on("ChangeActiveComponent", function(e) {
            if (!e.eventData) $("h4.active", context).removeClass("active");
        });
        $("div.controls > div.controlscontainer", context).children("div.save").children("button.save").click(function() {
            im.save();
        }).end().children("button.cancel").click(function() {
            if (confirm("Are you certain?")) $.fn.dialog.closeTop();
        });
        $("div.controls > div.controlscontainer", context).children("ul.nav").children().click(function() {
            if ($(this).hasClass("active")) return false;
            $("div.controls > div.controlscontainer", context).children("ul.nav").children().removeClass("active");
            $(this).addClass("active");
            im.trigger("ChangeNavTab", $(this).text().toLowerCase());
            return false;
        });
        $("div.controlset", context).find("div.control").children("div.contents").slideUp(0).end().end().find("h4").click(function() {
            if ($(this).parent().hasClass("disabled")) return;
            $(this).addClass("active");
            $("div.controlset", context).find("h4").not($(this)).removeClass("active");
            var ns = $(this).parent().attr("data-namespace");
            im.trigger("ChangeActiveAction", "ControlSet_" + ns);
        });
        $("div.component", context).find("div.control").children("div.contents").slideUp(0).hide().end().end().find("h4").click(function() {
            if ($(this).hasClass("active")) return false;
            $(this).addClass("active");
            $("div.component", context).children("h4").not($(this)).removeClass("active");
            var ns = $(this).parent().attr("data-namespace");
            im.trigger("ChangeActiveComponent", "Component_" + ns);
        });
        $("div.components").hide();
        im.bind("imageload", $.fn.dialog.hideLoader);
        return im;
    };
    $.fn.slideOut = function(time, callback) {
        var me = $(this), startWidth = me.width(), totalWidth = 300;
        me.css("overflow-y", "auto");
        if (startWidth == totalWidth) {
            me.animate({
                width: totalWidth
            }, 0, callback);
            return this;
        }
        me.width(startWidth).animate({
            width: totalWidth
        }, time || 300, callback || function() {});
        return this;
    };
    $.fn.slideIn = function(time, callback) {
        var me = $(this);
        me.css("overflow-y", "hidden");
        if (me.width() === 0) {
            me.animate({
                width: 0
            }, 0, callback);
            return this;
        }
        me.animate({
            width: 0
        }, time || 300, callback || function() {});
        return this;
    };
    ImageEditor.prototype = ImageEditor.fn = {
        filter: {
            grayscale: Kinetic.Filters.Grayscale,
            sepia: function(imageData) {
                var i;
                var data = imageData.data;
                for (i = 0; i < data.length; i += 4) {
                    data[i] = data[i] * .393 + data[i + 1] * .769 + data[i + 2] * .189;
                    data[i + 1] = data[i] * .349 + data[i + 1] * .686 + data[i + 2] * .168;
                    data[i + 2] = data[i] * .272 + data[i + 1] * .534 + data[i + 2] * .131;
                }
            },
            brightness: function(imageData, ob) {
                var adjustment = ob.level;
                var d = imageData.data;
                for (var i = 0; i < d.length; i += 4) {
                    d[i] += adjustment;
                    d[i + 1] += adjustment;
                    d[i + 2] += adjustment;
                }
            },
            invert: function(imageData, ob) {
                var d = imageData.data;
                for (var i = 0; i < d.length; i += 4) {
                    d[i] = 255 - d[i];
                    d[i + 1] = 255 - d[i + 1];
                    d[i + 2] = 255 - d[i + 2];
                }
            },
            restore: function(imageData, ob) {
                var adjustment = ob.level;
                var d = imageData.data;
                var g = ob.imageData.data;
                for (var i = 0; i < d.length; i += 4) {
                    d[i] = g[i];
                    d[i + 1] = g[i + 1];
                    d[i + 2] = g[i + 2];
                }
            }
        }
    };
})(window, jQuery, Kinetic);